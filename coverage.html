
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>grpc_server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/ArtEmerged/o_chat-server/cmd/grpc_server/main.go (0.0%)</option>
				
				<option value="file1">github.com/ArtEmerged/o_chat-server/internal/adapter/chat.go (100.0%)</option>
				
				<option value="file2">github.com/ArtEmerged/o_chat-server/internal/adapter/message.go (100.0%)</option>
				
				<option value="file3">github.com/ArtEmerged/o_chat-server/internal/api/grpc/chat/create.go (87.5%)</option>
				
				<option value="file4">github.com/ArtEmerged/o_chat-server/internal/api/grpc/chat/delete.go (100.0%)</option>
				
				<option value="file5">github.com/ArtEmerged/o_chat-server/internal/api/grpc/chat/send_message.go (83.3%)</option>
				
				<option value="file6">github.com/ArtEmerged/o_chat-server/internal/api/grpc/chat/service.go (100.0%)</option>
				
				<option value="file7">github.com/ArtEmerged/o_chat-server/internal/app/app.go (0.0%)</option>
				
				<option value="file8">github.com/ArtEmerged/o_chat-server/internal/app/service_provide.go (0.0%)</option>
				
				<option value="file9">github.com/ArtEmerged/o_chat-server/internal/closer/closer.go (0.0%)</option>
				
				<option value="file10">github.com/ArtEmerged/o_chat-server/internal/config/config.go (0.0%)</option>
				
				<option value="file11">github.com/ArtEmerged/o_chat-server/internal/model/chat.go (100.0%)</option>
				
				<option value="file12">github.com/ArtEmerged/o_chat-server/internal/model/message.go (100.0%)</option>
				
				<option value="file13">github.com/ArtEmerged/o_chat-server/internal/repository/chat/adapter/chat.go (0.0%)</option>
				
				<option value="file14">github.com/ArtEmerged/o_chat-server/internal/repository/chat/create.go (0.0%)</option>
				
				<option value="file15">github.com/ArtEmerged/o_chat-server/internal/repository/chat/delete.go (0.0%)</option>
				
				<option value="file16">github.com/ArtEmerged/o_chat-server/internal/repository/chat/repository.go (0.0%)</option>
				
				<option value="file17">github.com/ArtEmerged/o_chat-server/internal/repository/message/adapter/message.go (0.0%)</option>
				
				<option value="file18">github.com/ArtEmerged/o_chat-server/internal/repository/message/repository.go (0.0%)</option>
				
				<option value="file19">github.com/ArtEmerged/o_chat-server/internal/repository/message/send.go (0.0%)</option>
				
				<option value="file20">github.com/ArtEmerged/o_chat-server/internal/repository/mocks/chat_repo_minimock.go (31.3%)</option>
				
				<option value="file21">github.com/ArtEmerged/o_chat-server/internal/repository/mocks/message_repo_minimock.go (33.3%)</option>
				
				<option value="file22">github.com/ArtEmerged/o_chat-server/internal/service/chat/create.go (90.0%)</option>
				
				<option value="file23">github.com/ArtEmerged/o_chat-server/internal/service/chat/delete.go (85.7%)</option>
				
				<option value="file24">github.com/ArtEmerged/o_chat-server/internal/service/chat/helpers.go (100.0%)</option>
				
				<option value="file25">github.com/ArtEmerged/o_chat-server/internal/service/chat/service.go (100.0%)</option>
				
				<option value="file26">github.com/ArtEmerged/o_chat-server/internal/service/chat/tests/support/txmanagerface.go (100.0%)</option>
				
				<option value="file27">github.com/ArtEmerged/o_chat-server/internal/service/message/send.go (100.0%)</option>
				
				<option value="file28">github.com/ArtEmerged/o_chat-server/internal/service/message/service.go (100.0%)</option>
				
				<option value="file29">github.com/ArtEmerged/o_chat-server/internal/service/mocks/chat_service_minimock.go (32.7%)</option>
				
				<option value="file30">github.com/ArtEmerged/o_chat-server/internal/service/mocks/message_service_minimock.go (33.3%)</option>
				
				<option value="file31">github.com/ArtEmerged/o_chat-server/pkg/chat_v1/chat.pb.go (16.8%)</option>
				
				<option value="file32">github.com/ArtEmerged/o_chat-server/pkg/chat_v1/chat_grpc.pb.go (0.0%)</option>
				
				<option value="file33">github.com/ArtEmerged/o_chat-server/pkg/database/postgres.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "log"

        "github.com/ArtEmerged/o_chat-server/internal/app"
)

func main() <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        a, err := app.New(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to init app: %v", err)
                return
        }</span>

        <span class="cov0" title="0">err = a.Run()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to run app: %v", err)
        }</span>

}
</pre>
		
		<pre class="file" id="file1" style="display: none">package adapter

import (
        "github.com/ArtEmerged/o_chat-server/internal/model"
        desc "github.com/ArtEmerged/o_chat-server/pkg/chat_v1"
)

// CreateChatRequestFromProto converts CreateChatRequest proto to local CreateChatRequest
func CreateChatRequestFromProto(in *desc.CreateChatRequest) *model.CreateChatRequest <span class="cov8" title="1">{
        return &amp;model.CreateChatRequest{
                ChatName:  in.GetChatName(),
                CreatorID: in.GetCreatorId(),
                UserIDs:   in.GetUserIds(),
        }
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package adapter

import (
        "github.com/ArtEmerged/o_chat-server/internal/model"
        desc "github.com/ArtEmerged/o_chat-server/pkg/chat_v1"
)

// SendMessageRequestFromProto converts SendMessageRequest proto to local SendMessageRequest
func SendMessageRequestFromProto(in *desc.SendMessageRequest) *model.SendMessageRequest <span class="cov8" title="1">{
        return &amp;model.SendMessageRequest{
                ChatID:     in.GetChatId(),
                FromUserID: in.GetFromUserId(),
                Text:       in.GetText(),
        }
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package chat

import (
        "context"
        "errors"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        "github.com/ArtEmerged/o_chat-server/internal/adapter"
        "github.com/ArtEmerged/o_chat-server/internal/model"
        desc "github.com/ArtEmerged/o_chat-server/pkg/chat_v1"
)

// CreateChat creates new chat by chat name and creator id with user ids.
func (s *Implementation) CreateChat(ctx context.Context, in *desc.CreateChatRequest) (*desc.CreateChatResponse, error) <span class="cov8" title="1">{
        if in.GetCreatorId() &lt; 1 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "negative creator id")
        }</span>

        <span class="cov8" title="1">id, err := s.chatService.CreateChat(ctx, adapter.CreateChatRequestFromProto(in))
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, model.ErrInvalidArgument) </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.InvalidArgument, err.Error())
                }</span>

                <span class="cov8" title="1">return nil, status.Error(codes.Internal, err.Error())</span>
        }

        <span class="cov8" title="1">return &amp;desc.CreateChatResponse{Id: int64(id)}, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package chat

import (
        "context"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/emptypb"

        desc "github.com/ArtEmerged/o_chat-server/pkg/chat_v1"
)

// DeleteChat deletes chat by id.
func (s *Implementation) DeleteChat(ctx context.Context, in *desc.DeleteChatRequest) (*emptypb.Empty, error) <span class="cov8" title="1">{
        if in.GetId() &lt; 1 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "negative id")
        }</span>

        <span class="cov8" title="1">err := s.chatService.DeleteChat(ctx, in.GetId())
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Error(codes.Internal, err.Error())
        }</span>

        <span class="cov8" title="1">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package chat

import (
        "context"
        "errors"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        "github.com/ArtEmerged/o_chat-server/internal/adapter"
        "github.com/ArtEmerged/o_chat-server/internal/model"
        desc "github.com/ArtEmerged/o_chat-server/pkg/chat_v1"
)

// SendMessage sends message to chat.
func (s *Implementation) SendMessage(ctx context.Context, in *desc.SendMessageRequest) (*desc.SendMessageResponse, error) <span class="cov8" title="1">{
        if in.GetFromUserId() &lt; 1 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "negative from_user_id")
        }</span>

        <span class="cov8" title="1">if in.GetChatId() &lt; 1 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "negative id")
        }</span>

        <span class="cov8" title="1">err := s.messageService.SendMessage(ctx, adapter.SendMessageRequestFromProto(in))
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, model.ErrNotFound) </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.NotFound, err.Error())
                }</span>

                <span class="cov8" title="1">if errors.Is(err, model.ErrInvalidArgument) </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.InvalidArgument, err.Error())
                }</span>

                <span class="cov8" title="1">return nil, status.Error(codes.Internal, err.Error())</span>
        }

        <span class="cov8" title="1">return &amp;desc.SendMessageResponse{}, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package chat

import (
        "github.com/ArtEmerged/o_chat-server/internal/service"
        desc "github.com/ArtEmerged/o_chat-server/pkg/chat_v1"
)

var _ desc.ChatV1Server = (*Implementation)(nil)

// Implementation implements chat gRPC interface.
type Implementation struct {
        desc.UnimplementedChatV1Server

        chatService    service.ChatService
        messageService service.MessageService
}

// NewImplementation registers the chat service on the gRPC server.
// s - pointer to the gRPC server
// service - the chat service interface to be registered
func NewImplementation(chatService service.ChatService, messageService service.MessageService) *Implementation <span class="cov8" title="1">{
        return &amp;Implementation{
                chatService:    chatService,
                messageService: messageService,
        }
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package app

import (
        "context"
        "log"
        "net"

        "github.com/ArtEmerged/o_chat-server/internal/closer"
        desc "github.com/ArtEmerged/o_chat-server/pkg/chat_v1"

        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
        "google.golang.org/grpc/reflection"
)

// App represents application
type App struct {
        grpcServer *grpc.Server

        serviceProvider *serviceProvider
}

// New creates new app instance
func New(ctx context.Context) (*App, error) <span class="cov0" title="0">{
        a := &amp;App{}

        err := a.initDeps(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return a, nil</span>
}

// Run starts application
func (a *App) Run() error <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                closer.CloseAll()
                closer.Wite()
        }</span>()

        <span class="cov0" title="0">return a.runGRPCServer()</span>
}

func (a *App) initDeps(ctx context.Context) error <span class="cov0" title="0">{
        inits := []func(context.Context) error{
                a.initServiceProvider,
                a.initGRPCServer,
        }

        for _, f := range inits </span><span class="cov0" title="0">{
                err := f(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (a *App) initServiceProvider(_ context.Context) error <span class="cov0" title="0">{
        a.serviceProvider = newServiceProvider()

        return nil
}</span>

func (a *App) initGRPCServer(ctx context.Context) error <span class="cov0" title="0">{
        a.grpcServer = grpc.NewServer(grpc.Creds(insecure.NewCredentials()))

        reflection.Register(a.grpcServer)

        desc.RegisterChatV1Server(a.grpcServer, a.serviceProvider.ChatImplementation(ctx))

        return nil
}</span>

func (a *App) runGRPCServer() error <span class="cov0" title="0">{
        log.Printf("GRPC server is running on %s", a.serviceProvider.GlobalConfig().ServerAddress())

        list, err := net.Listen("tcp", a.serviceProvider.GlobalConfig().ServerAddress())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = a.grpcServer.Serve(list)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package app

import (
        "context"
        "log"

        "github.com/ArtEmerged/library/client/cache"
        "github.com/ArtEmerged/library/client/cache/redis"
        "github.com/ArtEmerged/library/client/db"
        "github.com/ArtEmerged/library/client/db/pg"
        "github.com/ArtEmerged/library/client/db/transaction"

        "github.com/ArtEmerged/o_chat-server/internal/api/grpc/chat"
        "github.com/ArtEmerged/o_chat-server/internal/closer"
        "github.com/ArtEmerged/o_chat-server/internal/config"
        "github.com/ArtEmerged/o_chat-server/internal/repository"
        chatRepo "github.com/ArtEmerged/o_chat-server/internal/repository/chat"
        messageRepo "github.com/ArtEmerged/o_chat-server/internal/repository/message"
        "github.com/ArtEmerged/o_chat-server/internal/service"
        chatServ "github.com/ArtEmerged/o_chat-server/internal/service/chat"
        messageServ "github.com/ArtEmerged/o_chat-server/internal/service/message"
)

type serviceProvider struct {
        globalConfig *config.Config
        redisConfig  redis.Config

        dbClient  db.Client
        txManager db.TxManager
        cache     cache.Cache

        chatRepository    repository.ChatRepo
        messageRepository repository.MessageRepo

        chatService    service.ChatService
        messageService service.MessageService

        chatImpl *chat.Implementation
}

func newServiceProvider() *serviceProvider <span class="cov0" title="0">{
        return &amp;serviceProvider{}
}</span>

// GlobalConfig returns the global config.
func (s *serviceProvider) GlobalConfig() *config.Config <span class="cov0" title="0">{
        if s.globalConfig == nil </span><span class="cov0" title="0">{
                s.globalConfig = config.New()

                err := s.globalConfig.Init("")
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("failed init config: %v", err)
                }</span>
        }

        <span class="cov0" title="0">return s.globalConfig</span>
}

// RedisConfig returns the redis config.
func (s *serviceProvider) RedisConfig() redis.Config <span class="cov0" title="0">{
        if s.redisConfig == nil </span><span class="cov0" title="0">{
                s.redisConfig = s.GlobalConfig().RedisConfig()
        }</span>

        <span class="cov0" title="0">return s.redisConfig</span>
}

// DBClient returns the db client.
func (s *serviceProvider) DBClient(ctx context.Context) db.Client <span class="cov0" title="0">{
        if s.dbClient == nil </span><span class="cov0" title="0">{
                cl, err := pg.New(ctx, s.GlobalConfig().DbDNS())
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("failed to create db client: %v", err)
                }</span>

                <span class="cov0" title="0">err = cl.DB().Ping(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("failed to ping db: %v", err)
                }</span>
                <span class="cov0" title="0">closer.Add(cl.Close)

                s.dbClient = cl</span>
        }

        <span class="cov0" title="0">return s.dbClient</span>
}

// TxManager returns the transaction manager.
func (s *serviceProvider) TxManager(ctx context.Context) db.TxManager <span class="cov0" title="0">{
        if s.txManager == nil </span><span class="cov0" title="0">{
                s.txManager = transaction.NewTransactionManager(s.DBClient(ctx).DB())
        }</span>

        <span class="cov0" title="0">return s.txManager</span>
}

// Cache returns the cache.
func (s *serviceProvider) Cache(ctx context.Context) cache.Cache <span class="cov0" title="0">{
        if s.cache == nil </span><span class="cov0" title="0">{
                s.cache = redis.NewClient(s.RedisConfig())
                err := s.cache.Ping(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("failed to ping redis: %v", err)
                }</span>

                <span class="cov0" title="0">closer.Add(s.cache.Close)</span>
        }

        <span class="cov0" title="0">return s.cache</span>
}

// ChatRepository returns the chat repository.
func (s *serviceProvider) ChatRepository(ctx context.Context) repository.ChatRepo <span class="cov0" title="0">{
        if s.chatRepository == nil </span><span class="cov0" title="0">{
                s.chatRepository = chatRepo.New(s.DBClient(ctx), s.Cache(ctx))
        }</span>

        <span class="cov0" title="0">return s.chatRepository</span>
}

// MessageRepository returns the message repository.
func (s *serviceProvider) MessageRepository(ctx context.Context) repository.MessageRepo <span class="cov0" title="0">{
        if s.messageRepository == nil </span><span class="cov0" title="0">{
                s.messageRepository = messageRepo.New(s.DBClient(ctx), s.Cache(ctx))
        }</span>

        <span class="cov0" title="0">return s.messageRepository</span>
}

// ChatService returns the chat service.
func (s *serviceProvider) ChatService(ctx context.Context) service.ChatService <span class="cov0" title="0">{
        if s.chatService == nil </span><span class="cov0" title="0">{
                s.chatService = chatServ.New(s.ChatRepository(ctx), s.TxManager(ctx), s.Cache(ctx))
        }</span>

        <span class="cov0" title="0">return s.chatService</span>
}

// MessageService returns the message service.
func (s *serviceProvider) MessageService(ctx context.Context) service.MessageService <span class="cov0" title="0">{
        if s.messageService == nil </span><span class="cov0" title="0">{
                s.messageService = messageServ.New(s.MessageRepository(ctx), s.Cache(ctx), s.TxManager(ctx))
        }</span>

        <span class="cov0" title="0">return s.messageService</span>
}

// ChatImplementation returns the chat implementation.
func (s *serviceProvider) ChatImplementation(ctx context.Context) *chat.Implementation <span class="cov0" title="0">{
        if s.chatImpl == nil </span><span class="cov0" title="0">{
                s.chatImpl = chat.NewImplementation(s.ChatService(ctx), s.MessageService(ctx))
        }</span>

        <span class="cov0" title="0">return s.chatImpl</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package closer

import (
        "log"
        "os"
        "os/signal"
        "sync"
)

var globalCloser = New()

// Add adds new closers
func Add(fs ...func() error) <span class="cov0" title="0">{
        globalCloser.Add(fs...)
}</span>

// Wite wites all closers
func Wite() <span class="cov0" title="0">{
        globalCloser.Wite()
}</span>

// CloseAll closes all closers functions
func CloseAll() <span class="cov0" title="0">{
        globalCloser.CloseAll()
}</span>

// Closer closes all closers
type Closer struct {
        done chan struct{}
        once sync.Once
        mu   sync.RWMutex
        fs   []func() error
}

// New creates a new instance of Closer
func New(signals ...os.Signal) *Closer <span class="cov0" title="0">{
        c := &amp;Closer{done: make(chan struct{})}

        if len(signals) &gt; 0 </span><span class="cov0" title="0">{
                go func() </span><span class="cov0" title="0">{
                        sign := make(chan os.Signal, 1)
                        signal.Notify(sign, signals...)
                        &lt;-sign
                        signal.Stop(sign)

                        c.CloseAll()
                }</span>()

        }

        <span class="cov0" title="0">return c</span>
}

// Add adds new closers
func (c *Closer) Add(fs ...func() error) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.fs = append(c.fs, fs...)
}</span>

// Wite wites all closers
func (c *Closer) Wite() <span class="cov0" title="0">{
        &lt;-c.done
}</span>

// CloseAll closes all closers functions
func (c *Closer) CloseAll() <span class="cov0" title="0">{
        c.once.Do(func() </span><span class="cov0" title="0">{
                defer close(c.done)

                c.mu.Lock()
                fs := c.fs
                c.fs = nil
                c.mu.Unlock()

                errs := make(chan error, len(fs))

                for _, f := range fs </span><span class="cov0" title="0">{
                        go func(f func() error) </span><span class="cov0" title="0">{
                                errs &lt;- f()
                        }</span>(f)
                }

                <span class="cov0" title="0">for i := 0; i &lt; cap(errs); i++ </span><span class="cov0" title="0">{
                        if err := &lt;-errs; err != nil </span><span class="cov0" title="0">{
                                log.Println("error returned from Closer")
                        }</span>
                }
        })
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package config

import (
        "fmt"
        "net"
        "time"

        "github.com/joho/godotenv"
        "github.com/kelseyhightower/envconfig"
)

const (
        serverHost     = "localhost"
        defaultEnvFile = ".env"
)

// Config is the config struct.
type Config struct {
        ServerPort string `envconfig:"SERVER_PORT" default:"50052"`

        DBName     string `envconfig:"DB_NAME"`
        DBHost     string `envconfig:"DB_HOST"`
        DBPort     string `envconfig:"DB_PORT"`
        DBUser     string `envconfig:"DB_USER"`
        DBPassword string `envconfig:"DB_PASSWORD"`

        RedisHost              string        `envconfig:"REDIS_HOST"`
        RedisPort              string        `envconfig:"REDIS_PORT"`
        RedisMaxIdleConns      int           `envconfig:"REDIS_MAX_IDLE"`
        RedisConnectionTimeout time.Duration `envconfig:"REDIS_CONNECTION_TIMEOUT"`
        RedisIdleTimeout       time.Duration `envconfig:"REDIS_IDLE_TIMEOUT_SEC"`
}

// New creates a new config.
func New() *Config <span class="cov0" title="0">{
        return &amp;Config{}
}</span>

// Init initializes the config.
func (cfg *Config) Init(path string) error <span class="cov0" title="0">{
        if path == "" </span><span class="cov0" title="0">{
                path = defaultEnvFile
        }</span>

        <span class="cov0" title="0">err := godotenv.Load(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed load env: %w", err)
        }</span>

        <span class="cov0" title="0">err = envconfig.Process("", cfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed parse env: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetDbDNS returns the database connection string.
func (cfg *Config) DbDNS() string <span class="cov0" title="0">{
        return fmt.Sprintf("host=%s port=%s dbname=%s user=%s password=%s sslmode=disable",
                cfg.DBHost, cfg.DBPort, cfg.DBName, cfg.DBUser, cfg.DBPassword)
}</span>

// GetServerAddress returns the server address.
func (cfg *Config) ServerAddress() string <span class="cov0" title="0">{
        return net.JoinHostPort(serverHost, cfg.ServerPort)
}</span>

type redisConfig struct {
        Host              string
        Port              string
        maxIdleConns      int
        connectionTimeout time.Duration
        idleTimeout       time.Duration
}

// RedisConfig returns the redis config.
func (cfg *Config) RedisConfig() *redisConfig <span class="cov0" title="0">{
        return &amp;redisConfig{
                Host:              cfg.RedisHost,
                Port:              cfg.RedisPort,
                maxIdleConns:      cfg.RedisMaxIdleConns,
                connectionTimeout: cfg.RedisConnectionTimeout,
                idleTimeout:       cfg.RedisIdleTimeout,
        }
}</span>

// Address returns the redis address.
func (r redisConfig) Address() string <span class="cov0" title="0">{
        return net.JoinHostPort(r.Host, r.Port)
}</span>

// MaxIdle returns the max idle connections.
func (r redisConfig) ConnectionTimeout() time.Duration <span class="cov0" title="0">{
        return r.connectionTimeout
}</span>

// MaxIdle returns the max idle connections.
func (r redisConfig) MaxIdle() int <span class="cov0" title="0">{
        return int(r.maxIdleConns)
}</span>

// IdleTimeout returns the idle timeout.
func (r redisConfig) IdleTimeout() time.Duration <span class="cov0" title="0">{
        return r.idleTimeout
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package model

import (
        "fmt"
        "strings"
)

const chatCacheKey = "chats:chat:%d"

// ChatCacheKey returns key for chat
func ChatCacheKey(chatID int64) string <span class="cov8" title="1">{
        return fmt.Sprintf(chatCacheKey, chatID)
}</span>

// Chat is a model for chat.
type Chat struct {
        ID        int64   `json:"id"`
        ChatName  string  `json:"chat_name"`
        CreatorID int64   `json:"creator_id"`
        UserIDs   []int64 `json:"user_ids"`
}

// CreateChatRequest is a request for method CreateChat.
type CreateChatRequest struct {
        ChatName  string
        CreatorID int64
        UserIDs   []int64
}

// Validate validates CreateChatRequest.
func (r *CreateChatRequest) Validate() error <span class="cov8" title="1">{
        var errsText []string

        // validate required fields
        if r.ChatName == "" </span><span class="cov8" title="1">{
                errsText = append(errsText, "field chat_name is required")
        }</span>

        <span class="cov8" title="1">if len(errsText) &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: %s", ErrInvalidArgument, strings.Join(errsText, ", "))
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package model

import (
        "fmt"
        "strings"
        "time"
)

// SendMessageRequest is a request for method SendMessage.
type SendMessageRequest struct {
        ChatID     int64
        FromUserID int64
        Text       string
}

// Validate validates SendMessageRequest
func (r *SendMessageRequest) Validate() error <span class="cov8" title="1">{
        var errsText []string

        if r.Text == "" </span><span class="cov8" title="1">{
                errsText = append(errsText, "field text is required")
        }</span>

        <span class="cov8" title="1">if len(errsText) &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: %s", ErrInvalidArgument, strings.Join(errsText, ", "))
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Message is a message
type Message struct {
        ID         int64     `json:"id"`
        ChatID     int64     `json:"chat_id"`
        FromUserID int64     `json:"from_user_id"`
        Text       string    `json:"text"`
        CreatedAt  time.Time `json:"created_at"`
}

// CreateMessageKey returns key for chat messages
func CreateMessageKey(chatID int64) string <span class="cov8" title="1">{
        return fmt.Sprintf("chats:chat:%d:messages", chatID)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package adapter

import (
        "time"

        "github.com/ArtEmerged/o_chat-server/internal/model"
        modelRepo "github.com/ArtEmerged/o_chat-server/internal/repository/chat/model"
)

// CreateChatRequestToRepo converts CreateChatRequest proto to repository CreateChatRequest
func CreateChatRequestToRepo(in *model.CreateChatRequest) *modelRepo.CreateChatRequest <span class="cov0" title="0">{
        return &amp;modelRepo.CreateChatRequest{
                Name:     in.ChatName,
                Owner:    in.CreatorID,
                CreateAt: time.Now().UTC(),
        }
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package chat

import (
        "context"
        "fmt"
        "strings"

        "github.com/ArtEmerged/library/client/db"

        "github.com/ArtEmerged/o_chat-server/internal/model"
        "github.com/ArtEmerged/o_chat-server/internal/repository/chat/adapter"
)

// CreateChat creates new chat by chat name and creator id.
func (r *chatRepo) CreateChat(ctx context.Context, in *model.CreateChatRequest) (id int64, err error) <span class="cov0" title="0">{
        newChat := adapter.CreateChatRequestToRepo(in)

        q := db.Query{
                Name: "chat_repository.CreateChat",
        }

        q.QueryRaw =
                `INSERT INTO public.chats (name, owner, created_at)
                VALUES ($1, $2, $3) 
                RETURNING id;`

        var chatID int64

        err = r.db.DB().QueryRowContext(ctx, q, newChat.Name, newChat.Owner, newChat.CreateAt).Scan(&amp;chatID)
        if err != nil </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("failed to create chat: %w", err)
        }</span>

        <span class="cov0" title="0">return chatID, nil</span>
}

// AddUsersToChat adds users to chat.
func (r *chatRepo) AddUsersToChat(ctx context.Context, chatID int64, userIDs []int64) error <span class="cov0" title="0">{
        args := []interface{}{chatID}
        values := strings.Builder{}

        for i, userID := range userIDs </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        values.WriteString(", ")
                }</span>
                <span class="cov0" title="0">values.WriteString(fmt.Sprintf("($1, $%d)", i+2))
                args = append(args, userID)</span>

        }

        <span class="cov0" title="0">q := db.Query{
                Name: "chat_repository.AddUsersToChat",
        }

        q.QueryRaw = fmt.Sprintf(
                `INSERT INTO public.chat_users (chat_id, user_id) 
                VALUES %s`, values.String())

        _, err := r.db.DB().ExecContext(ctx, q, args...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add users to chat: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package chat

import (
        "context"
        "fmt"
        "time"

        "github.com/ArtEmerged/library/client/db"
)

// DeleteChat deletes chat by id.
func (r *chatRepo) DeleteChat(ctx context.Context, id int64) error <span class="cov0" title="0">{
        q := db.Query{
                Name: "deleted_repository.DeleteChat",
        }

        q.QueryRaw =
                `UPDATE public.chats
                SET deleted_at = $1
                WHERE id = $2 AND deleted_at IS NULL;`

        createdAt := time.Now().UTC()

        _, err := r.db.DB().ExecContext(ctx, q, createdAt, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete chat: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package chat

import (
        "github.com/ArtEmerged/library/client/cache"
        dbClient "github.com/ArtEmerged/library/client/db"

        "github.com/ArtEmerged/o_chat-server/internal/repository"
)

type chatRepo struct {
        db    dbClient.Client
        cache cache.Cache
}

// New creates a new instance of chatRepo with the given database connection pool.
// db - database connection pool
func New(db dbClient.Client, cache cache.Cache) repository.ChatRepo <span class="cov0" title="0">{
        return &amp;chatRepo{db: db, cache: cache}
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package adapter

import (
        "time"

        "github.com/ArtEmerged/o_chat-server/internal/model"

        modelRepo "github.com/ArtEmerged/o_chat-server/internal/repository/message/model"
)

// SendMessageRequestToRepo converts SendMessageRequest local to repo SendMessageRequest
func SendMessageRequestToRepo(in *model.SendMessageRequest) *modelRepo.SendMessageRequest <span class="cov0" title="0">{
        return &amp;modelRepo.SendMessageRequest{
                ChatID:     in.ChatID,
                FromUserID: in.FromUserID,
                Text:       in.Text,
                CreatedAt:  time.Now().UTC(),
        }
}</span>

func MessageToModel(in *modelRepo.Message) *model.Message <span class="cov0" title="0">{
        return &amp;model.Message{
                ID:         in.ID,
                ChatID:     in.ChatID,
                FromUserID: in.FromUserID,
                Text:       in.Text,
                CreatedAt:  in.CreatedAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package message

import (
        "github.com/ArtEmerged/library/client/cache"
        dbClient "github.com/ArtEmerged/library/client/db"

        "github.com/ArtEmerged/o_chat-server/internal/repository"
)

type messageRepo struct {
        db    dbClient.Client
        cache cache.Cache
}

// New creates a new instance of messageRepo with the given database connection pool.
// db - database connection pool
func New(db dbClient.Client, cache cache.Cache) repository.MessageRepo <span class="cov0" title="0">{
        return &amp;messageRepo{db: db, cache: cache}
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package message

import (
        "context"
        "fmt"

        "github.com/ArtEmerged/library/client/db"

        "github.com/ArtEmerged/o_chat-server/internal/model"
        "github.com/ArtEmerged/o_chat-server/internal/repository/message/adapter"
        repoModel "github.com/ArtEmerged/o_chat-server/internal/repository/message/model"
)

// SendMessage sends message to chat by chat id and from user id.
func (r *messageRepo) SendMessage(ctx context.Context, in *model.SendMessageRequest) (*model.Message, error) <span class="cov0" title="0">{
        q := db.Query{
                Name: "message_repository.SendMessage",
        }

        q.QueryRaw =`
        INSERT INTO public.chat_messages (chat_id, from_user_id, text, created_at)
                SELECT $1, $2, $3, $4
        WHERE EXISTS (
            SELECT 1 
            FROM public.chats 
            WHERE id = $1 AND deleted_at IS NULL
        )
        AND EXISTS (
            SELECT 1 
            FROM public.chat_users 
            WHERE chat_id = $1 AND user_id = $2
        )
        RETURNING id, chat_id, from_user_id, text, created_at;`

        msg := adapter.SendMessageRequestToRepo(in)

        message := new(repoModel.Message)
        err := r.db.DB().ScanOneContext(
                ctx,
                message,
                q,
                msg.ChatID,
                msg.FromUserID,
                msg.Text,
                msg.CreatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed insert chat message: %w", err)
        }</span>

        <span class="cov0" title="0">return adapter.MessageToModel(message), nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Code generated by http://github.com/gojuno/minimock (v3.3.14). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/ArtEmerged/o_chat-server/internal/repository.ChatRepo -o chat_repo_minimock.go -n ChatRepoMock -p mocks

import (
        "context"
        "sync"
        mm_atomic "sync/atomic"
        mm_time "time"

        "github.com/ArtEmerged/o_chat-server/internal/model"
        "github.com/gojuno/minimock/v3"
)

// ChatRepoMock implements repository.ChatRepo
type ChatRepoMock struct {
        t          minimock.Tester
        finishOnce sync.Once

        funcAddUsersToChat          func(ctx context.Context, chatID int64, userIDs []int64) (err error)
        inspectFuncAddUsersToChat   func(ctx context.Context, chatID int64, userIDs []int64)
        afterAddUsersToChatCounter  uint64
        beforeAddUsersToChatCounter uint64
        AddUsersToChatMock          mChatRepoMockAddUsersToChat

        funcCreateChat          func(ctx context.Context, in *model.CreateChatRequest) (id int64, err error)
        inspectFuncCreateChat   func(ctx context.Context, in *model.CreateChatRequest)
        afterCreateChatCounter  uint64
        beforeCreateChatCounter uint64
        CreateChatMock          mChatRepoMockCreateChat

        funcDeleteChat          func(ctx context.Context, id int64) (err error)
        inspectFuncDeleteChat   func(ctx context.Context, id int64)
        afterDeleteChatCounter  uint64
        beforeDeleteChatCounter uint64
        DeleteChatMock          mChatRepoMockDeleteChat
}

// NewChatRepoMock returns a mock for repository.ChatRepo
func NewChatRepoMock(t minimock.Tester) *ChatRepoMock <span class="cov8" title="1">{
        m := &amp;ChatRepoMock{t: t}

        if controller, ok := t.(minimock.MockController); ok </span><span class="cov8" title="1">{
                controller.RegisterMocker(m)
        }</span>

        <span class="cov8" title="1">m.AddUsersToChatMock = mChatRepoMockAddUsersToChat{mock: m}
        m.AddUsersToChatMock.callArgs = []*ChatRepoMockAddUsersToChatParams{}

        m.CreateChatMock = mChatRepoMockCreateChat{mock: m}
        m.CreateChatMock.callArgs = []*ChatRepoMockCreateChatParams{}

        m.DeleteChatMock = mChatRepoMockDeleteChat{mock: m}
        m.DeleteChatMock.callArgs = []*ChatRepoMockDeleteChatParams{}

        t.Cleanup(m.MinimockFinish)

        return m</span>
}

type mChatRepoMockAddUsersToChat struct {
        optional           bool
        mock               *ChatRepoMock
        defaultExpectation *ChatRepoMockAddUsersToChatExpectation
        expectations       []*ChatRepoMockAddUsersToChatExpectation

        callArgs []*ChatRepoMockAddUsersToChatParams
        mutex    sync.RWMutex

        expectedInvocations uint64
}

// ChatRepoMockAddUsersToChatExpectation specifies expectation struct of the ChatRepo.AddUsersToChat
type ChatRepoMockAddUsersToChatExpectation struct {
        mock      *ChatRepoMock
        params    *ChatRepoMockAddUsersToChatParams
        paramPtrs *ChatRepoMockAddUsersToChatParamPtrs
        results   *ChatRepoMockAddUsersToChatResults
        Counter   uint64
}

// ChatRepoMockAddUsersToChatParams contains parameters of the ChatRepo.AddUsersToChat
type ChatRepoMockAddUsersToChatParams struct {
        ctx     context.Context
        chatID  int64
        userIDs []int64
}

// ChatRepoMockAddUsersToChatParamPtrs contains pointers to parameters of the ChatRepo.AddUsersToChat
type ChatRepoMockAddUsersToChatParamPtrs struct {
        ctx     *context.Context
        chatID  *int64
        userIDs *[]int64
}

// ChatRepoMockAddUsersToChatResults contains results of the ChatRepo.AddUsersToChat
type ChatRepoMockAddUsersToChatResults struct {
        err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddUsersToChat *mChatRepoMockAddUsersToChat) Optional() *mChatRepoMockAddUsersToChat <span class="cov0" title="0">{
        mmAddUsersToChat.optional = true
        return mmAddUsersToChat
}</span>

// Expect sets up expected params for ChatRepo.AddUsersToChat
func (mmAddUsersToChat *mChatRepoMockAddUsersToChat) Expect(ctx context.Context, chatID int64, userIDs []int64) *mChatRepoMockAddUsersToChat <span class="cov8" title="1">{
        if mmAddUsersToChat.mock.funcAddUsersToChat != nil </span><span class="cov0" title="0">{
                mmAddUsersToChat.mock.t.Fatalf("ChatRepoMock.AddUsersToChat mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmAddUsersToChat.defaultExpectation == nil </span><span class="cov8" title="1">{
                mmAddUsersToChat.defaultExpectation = &amp;ChatRepoMockAddUsersToChatExpectation{}
        }</span>

        <span class="cov8" title="1">if mmAddUsersToChat.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmAddUsersToChat.mock.t.Fatalf("ChatRepoMock.AddUsersToChat mock is already set by ExpectParams functions")
        }</span>

        <span class="cov8" title="1">mmAddUsersToChat.defaultExpectation.params = &amp;ChatRepoMockAddUsersToChatParams{ctx, chatID, userIDs}
        for _, e := range mmAddUsersToChat.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmAddUsersToChat.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmAddUsersToChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddUsersToChat.defaultExpectation.params)
                }</span>
        }

        <span class="cov8" title="1">return mmAddUsersToChat</span>
}

// ExpectCtxParam1 sets up expected param ctx for ChatRepo.AddUsersToChat
func (mmAddUsersToChat *mChatRepoMockAddUsersToChat) ExpectCtxParam1(ctx context.Context) *mChatRepoMockAddUsersToChat <span class="cov0" title="0">{
        if mmAddUsersToChat.mock.funcAddUsersToChat != nil </span><span class="cov0" title="0">{
                mmAddUsersToChat.mock.t.Fatalf("ChatRepoMock.AddUsersToChat mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmAddUsersToChat.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmAddUsersToChat.defaultExpectation = &amp;ChatRepoMockAddUsersToChatExpectation{}
        }</span>

        <span class="cov0" title="0">if mmAddUsersToChat.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmAddUsersToChat.mock.t.Fatalf("ChatRepoMock.AddUsersToChat mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmAddUsersToChat.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmAddUsersToChat.defaultExpectation.paramPtrs = &amp;ChatRepoMockAddUsersToChatParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmAddUsersToChat.defaultExpectation.paramPtrs.ctx = &amp;ctx

        return mmAddUsersToChat</span>
}

// ExpectChatIDParam2 sets up expected param chatID for ChatRepo.AddUsersToChat
func (mmAddUsersToChat *mChatRepoMockAddUsersToChat) ExpectChatIDParam2(chatID int64) *mChatRepoMockAddUsersToChat <span class="cov0" title="0">{
        if mmAddUsersToChat.mock.funcAddUsersToChat != nil </span><span class="cov0" title="0">{
                mmAddUsersToChat.mock.t.Fatalf("ChatRepoMock.AddUsersToChat mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmAddUsersToChat.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmAddUsersToChat.defaultExpectation = &amp;ChatRepoMockAddUsersToChatExpectation{}
        }</span>

        <span class="cov0" title="0">if mmAddUsersToChat.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmAddUsersToChat.mock.t.Fatalf("ChatRepoMock.AddUsersToChat mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmAddUsersToChat.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmAddUsersToChat.defaultExpectation.paramPtrs = &amp;ChatRepoMockAddUsersToChatParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmAddUsersToChat.defaultExpectation.paramPtrs.chatID = &amp;chatID

        return mmAddUsersToChat</span>
}

// ExpectUserIDsParam3 sets up expected param userIDs for ChatRepo.AddUsersToChat
func (mmAddUsersToChat *mChatRepoMockAddUsersToChat) ExpectUserIDsParam3(userIDs []int64) *mChatRepoMockAddUsersToChat <span class="cov0" title="0">{
        if mmAddUsersToChat.mock.funcAddUsersToChat != nil </span><span class="cov0" title="0">{
                mmAddUsersToChat.mock.t.Fatalf("ChatRepoMock.AddUsersToChat mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmAddUsersToChat.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmAddUsersToChat.defaultExpectation = &amp;ChatRepoMockAddUsersToChatExpectation{}
        }</span>

        <span class="cov0" title="0">if mmAddUsersToChat.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmAddUsersToChat.mock.t.Fatalf("ChatRepoMock.AddUsersToChat mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmAddUsersToChat.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmAddUsersToChat.defaultExpectation.paramPtrs = &amp;ChatRepoMockAddUsersToChatParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmAddUsersToChat.defaultExpectation.paramPtrs.userIDs = &amp;userIDs

        return mmAddUsersToChat</span>
}

// Inspect accepts an inspector function that has same arguments as the ChatRepo.AddUsersToChat
func (mmAddUsersToChat *mChatRepoMockAddUsersToChat) Inspect(f func(ctx context.Context, chatID int64, userIDs []int64)) *mChatRepoMockAddUsersToChat <span class="cov0" title="0">{
        if mmAddUsersToChat.mock.inspectFuncAddUsersToChat != nil </span><span class="cov0" title="0">{
                mmAddUsersToChat.mock.t.Fatalf("Inspect function is already set for ChatRepoMock.AddUsersToChat")
        }</span>

        <span class="cov0" title="0">mmAddUsersToChat.mock.inspectFuncAddUsersToChat = f

        return mmAddUsersToChat</span>
}

// Return sets up results that will be returned by ChatRepo.AddUsersToChat
func (mmAddUsersToChat *mChatRepoMockAddUsersToChat) Return(err error) *ChatRepoMock <span class="cov8" title="1">{
        if mmAddUsersToChat.mock.funcAddUsersToChat != nil </span><span class="cov0" title="0">{
                mmAddUsersToChat.mock.t.Fatalf("ChatRepoMock.AddUsersToChat mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmAddUsersToChat.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmAddUsersToChat.defaultExpectation = &amp;ChatRepoMockAddUsersToChatExpectation{mock: mmAddUsersToChat.mock}
        }</span>
        <span class="cov8" title="1">mmAddUsersToChat.defaultExpectation.results = &amp;ChatRepoMockAddUsersToChatResults{err}
        return mmAddUsersToChat.mock</span>
}

// Set uses given function f to mock the ChatRepo.AddUsersToChat method
func (mmAddUsersToChat *mChatRepoMockAddUsersToChat) Set(f func(ctx context.Context, chatID int64, userIDs []int64) (err error)) *ChatRepoMock <span class="cov0" title="0">{
        if mmAddUsersToChat.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmAddUsersToChat.mock.t.Fatalf("Default expectation is already set for the ChatRepo.AddUsersToChat method")
        }</span>

        <span class="cov0" title="0">if len(mmAddUsersToChat.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmAddUsersToChat.mock.t.Fatalf("Some expectations are already set for the ChatRepo.AddUsersToChat method")
        }</span>

        <span class="cov0" title="0">mmAddUsersToChat.mock.funcAddUsersToChat = f
        return mmAddUsersToChat.mock</span>
}

// When sets expectation for the ChatRepo.AddUsersToChat which will trigger the result defined by the following
// Then helper
func (mmAddUsersToChat *mChatRepoMockAddUsersToChat) When(ctx context.Context, chatID int64, userIDs []int64) *ChatRepoMockAddUsersToChatExpectation <span class="cov0" title="0">{
        if mmAddUsersToChat.mock.funcAddUsersToChat != nil </span><span class="cov0" title="0">{
                mmAddUsersToChat.mock.t.Fatalf("ChatRepoMock.AddUsersToChat mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;ChatRepoMockAddUsersToChatExpectation{
                mock:   mmAddUsersToChat.mock,
                params: &amp;ChatRepoMockAddUsersToChatParams{ctx, chatID, userIDs},
        }
        mmAddUsersToChat.expectations = append(mmAddUsersToChat.expectations, expectation)
        return expectation</span>
}

// Then sets up ChatRepo.AddUsersToChat return parameters for the expectation previously defined by the When method
func (e *ChatRepoMockAddUsersToChatExpectation) Then(err error) *ChatRepoMock <span class="cov0" title="0">{
        e.results = &amp;ChatRepoMockAddUsersToChatResults{err}
        return e.mock
}</span>

// Times sets number of times ChatRepo.AddUsersToChat should be invoked
func (mmAddUsersToChat *mChatRepoMockAddUsersToChat) Times(n uint64) *mChatRepoMockAddUsersToChat <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmAddUsersToChat.mock.t.Fatalf("Times of ChatRepoMock.AddUsersToChat mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmAddUsersToChat.expectedInvocations, n)
        return mmAddUsersToChat</span>
}

func (mmAddUsersToChat *mChatRepoMockAddUsersToChat) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmAddUsersToChat.expectations) == 0 &amp;&amp; mmAddUsersToChat.defaultExpectation == nil &amp;&amp; mmAddUsersToChat.mock.funcAddUsersToChat == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">totalInvocations := mm_atomic.LoadUint64(&amp;mmAddUsersToChat.mock.afterAddUsersToChatCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmAddUsersToChat.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// AddUsersToChat implements repository.ChatRepo
func (mmAddUsersToChat *ChatRepoMock) AddUsersToChat(ctx context.Context, chatID int64, userIDs []int64) (err error) <span class="cov8" title="1">{
        mm_atomic.AddUint64(&amp;mmAddUsersToChat.beforeAddUsersToChatCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmAddUsersToChat.afterAddUsersToChatCounter, 1)

        if mmAddUsersToChat.inspectFuncAddUsersToChat != nil </span><span class="cov0" title="0">{
                mmAddUsersToChat.inspectFuncAddUsersToChat(ctx, chatID, userIDs)
        }</span>

        <span class="cov8" title="1">mm_params := ChatRepoMockAddUsersToChatParams{ctx, chatID, userIDs}

        // Record call args
        mmAddUsersToChat.AddUsersToChatMock.mutex.Lock()
        mmAddUsersToChat.AddUsersToChatMock.callArgs = append(mmAddUsersToChat.AddUsersToChatMock.callArgs, &amp;mm_params)
        mmAddUsersToChat.AddUsersToChatMock.mutex.Unlock()

        for _, e := range mmAddUsersToChat.AddUsersToChatMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov8" title="1">if mmAddUsersToChat.AddUsersToChatMock.defaultExpectation != nil </span><span class="cov8" title="1">{
                mm_atomic.AddUint64(&amp;mmAddUsersToChat.AddUsersToChatMock.defaultExpectation.Counter, 1)
                mm_want := mmAddUsersToChat.AddUsersToChatMock.defaultExpectation.params
                mm_want_ptrs := mmAddUsersToChat.AddUsersToChatMock.defaultExpectation.paramPtrs

                mm_got := ChatRepoMockAddUsersToChatParams{ctx, chatID, userIDs}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmAddUsersToChat.t.Errorf("ChatRepoMock.AddUsersToChat got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.chatID != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.chatID, mm_got.chatID) </span><span class="cov0" title="0">{
                                mmAddUsersToChat.t.Errorf("ChatRepoMock.AddUsersToChat got unexpected parameter chatID, want: %#v, got: %#v%s\n", *mm_want_ptrs.chatID, mm_got.chatID, minimock.Diff(*mm_want_ptrs.chatID, mm_got.chatID))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.userIDs != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.userIDs, mm_got.userIDs) </span><span class="cov0" title="0">{
                                mmAddUsersToChat.t.Errorf("ChatRepoMock.AddUsersToChat got unexpected parameter userIDs, want: %#v, got: %#v%s\n", *mm_want_ptrs.userIDs, mm_got.userIDs, minimock.Diff(*mm_want_ptrs.userIDs, mm_got.userIDs))
                        }</span>

                } else<span class="cov8" title="1"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmAddUsersToChat.t.Errorf("ChatRepoMock.AddUsersToChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov8" title="1">mm_results := mmAddUsersToChat.AddUsersToChatMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmAddUsersToChat.t.Fatal("No results are set for the ChatRepoMock.AddUsersToChat")
                }</span>
                <span class="cov8" title="1">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmAddUsersToChat.funcAddUsersToChat != nil </span><span class="cov0" title="0">{
                return mmAddUsersToChat.funcAddUsersToChat(ctx, chatID, userIDs)
        }</span>
        <span class="cov0" title="0">mmAddUsersToChat.t.Fatalf("Unexpected call to ChatRepoMock.AddUsersToChat. %v %v %v", ctx, chatID, userIDs)
        return</span>
}

// AddUsersToChatAfterCounter returns a count of finished ChatRepoMock.AddUsersToChat invocations
func (mmAddUsersToChat *ChatRepoMock) AddUsersToChatAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmAddUsersToChat.afterAddUsersToChatCounter)
}</span>

// AddUsersToChatBeforeCounter returns a count of ChatRepoMock.AddUsersToChat invocations
func (mmAddUsersToChat *ChatRepoMock) AddUsersToChatBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmAddUsersToChat.beforeAddUsersToChatCounter)
}</span>

// Calls returns a list of arguments used in each call to ChatRepoMock.AddUsersToChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddUsersToChat *mChatRepoMockAddUsersToChat) Calls() []*ChatRepoMockAddUsersToChatParams <span class="cov0" title="0">{
        mmAddUsersToChat.mutex.RLock()

        argCopy := make([]*ChatRepoMockAddUsersToChatParams, len(mmAddUsersToChat.callArgs))
        copy(argCopy, mmAddUsersToChat.callArgs)

        mmAddUsersToChat.mutex.RUnlock()

        return argCopy
}</span>

// MinimockAddUsersToChatDone returns true if the count of the AddUsersToChat invocations corresponds
// the number of defined expectations
func (m *ChatRepoMock) MinimockAddUsersToChatDone() bool <span class="cov8" title="1">{
        if m.AddUsersToChatMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.AddUsersToChatMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.AddUsersToChatMock.invocationsDone()</span>
}

// MinimockAddUsersToChatInspect logs each unmet expectation
func (m *ChatRepoMock) MinimockAddUsersToChatInspect() <span class="cov0" title="0">{
        for _, e := range m.AddUsersToChatMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to ChatRepoMock.AddUsersToChat with params: %#v", *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterAddUsersToChatCounter := mm_atomic.LoadUint64(&amp;m.afterAddUsersToChatCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.AddUsersToChatMock.defaultExpectation != nil &amp;&amp; afterAddUsersToChatCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.AddUsersToChatMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to ChatRepoMock.AddUsersToChat")
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to ChatRepoMock.AddUsersToChat with params: %#v", *m.AddUsersToChatMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcAddUsersToChat != nil &amp;&amp; afterAddUsersToChatCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Error("Expected call to ChatRepoMock.AddUsersToChat")
        }</span>

        <span class="cov0" title="0">if !m.AddUsersToChatMock.invocationsDone() &amp;&amp; afterAddUsersToChatCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to ChatRepoMock.AddUsersToChat but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.AddUsersToChatMock.expectedInvocations), afterAddUsersToChatCounter)
        }</span>
}

type mChatRepoMockCreateChat struct {
        optional           bool
        mock               *ChatRepoMock
        defaultExpectation *ChatRepoMockCreateChatExpectation
        expectations       []*ChatRepoMockCreateChatExpectation

        callArgs []*ChatRepoMockCreateChatParams
        mutex    sync.RWMutex

        expectedInvocations uint64
}

// ChatRepoMockCreateChatExpectation specifies expectation struct of the ChatRepo.CreateChat
type ChatRepoMockCreateChatExpectation struct {
        mock      *ChatRepoMock
        params    *ChatRepoMockCreateChatParams
        paramPtrs *ChatRepoMockCreateChatParamPtrs
        results   *ChatRepoMockCreateChatResults
        Counter   uint64
}

// ChatRepoMockCreateChatParams contains parameters of the ChatRepo.CreateChat
type ChatRepoMockCreateChatParams struct {
        ctx context.Context
        in  *model.CreateChatRequest
}

// ChatRepoMockCreateChatParamPtrs contains pointers to parameters of the ChatRepo.CreateChat
type ChatRepoMockCreateChatParamPtrs struct {
        ctx *context.Context
        in  **model.CreateChatRequest
}

// ChatRepoMockCreateChatResults contains results of the ChatRepo.CreateChat
type ChatRepoMockCreateChatResults struct {
        id  int64
        err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateChat *mChatRepoMockCreateChat) Optional() *mChatRepoMockCreateChat <span class="cov0" title="0">{
        mmCreateChat.optional = true
        return mmCreateChat
}</span>

// Expect sets up expected params for ChatRepo.CreateChat
func (mmCreateChat *mChatRepoMockCreateChat) Expect(ctx context.Context, in *model.CreateChatRequest) *mChatRepoMockCreateChat <span class="cov8" title="1">{
        if mmCreateChat.mock.funcCreateChat != nil </span><span class="cov0" title="0">{
                mmCreateChat.mock.t.Fatalf("ChatRepoMock.CreateChat mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmCreateChat.defaultExpectation == nil </span><span class="cov8" title="1">{
                mmCreateChat.defaultExpectation = &amp;ChatRepoMockCreateChatExpectation{}
        }</span>

        <span class="cov8" title="1">if mmCreateChat.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmCreateChat.mock.t.Fatalf("ChatRepoMock.CreateChat mock is already set by ExpectParams functions")
        }</span>

        <span class="cov8" title="1">mmCreateChat.defaultExpectation.params = &amp;ChatRepoMockCreateChatParams{ctx, in}
        for _, e := range mmCreateChat.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmCreateChat.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmCreateChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateChat.defaultExpectation.params)
                }</span>
        }

        <span class="cov8" title="1">return mmCreateChat</span>
}

// ExpectCtxParam1 sets up expected param ctx for ChatRepo.CreateChat
func (mmCreateChat *mChatRepoMockCreateChat) ExpectCtxParam1(ctx context.Context) *mChatRepoMockCreateChat <span class="cov0" title="0">{
        if mmCreateChat.mock.funcCreateChat != nil </span><span class="cov0" title="0">{
                mmCreateChat.mock.t.Fatalf("ChatRepoMock.CreateChat mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreateChat.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreateChat.defaultExpectation = &amp;ChatRepoMockCreateChatExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreateChat.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmCreateChat.mock.t.Fatalf("ChatRepoMock.CreateChat mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmCreateChat.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmCreateChat.defaultExpectation.paramPtrs = &amp;ChatRepoMockCreateChatParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmCreateChat.defaultExpectation.paramPtrs.ctx = &amp;ctx

        return mmCreateChat</span>
}

// ExpectInParam2 sets up expected param in for ChatRepo.CreateChat
func (mmCreateChat *mChatRepoMockCreateChat) ExpectInParam2(in *model.CreateChatRequest) *mChatRepoMockCreateChat <span class="cov0" title="0">{
        if mmCreateChat.mock.funcCreateChat != nil </span><span class="cov0" title="0">{
                mmCreateChat.mock.t.Fatalf("ChatRepoMock.CreateChat mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreateChat.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreateChat.defaultExpectation = &amp;ChatRepoMockCreateChatExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreateChat.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmCreateChat.mock.t.Fatalf("ChatRepoMock.CreateChat mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmCreateChat.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmCreateChat.defaultExpectation.paramPtrs = &amp;ChatRepoMockCreateChatParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmCreateChat.defaultExpectation.paramPtrs.in = &amp;in

        return mmCreateChat</span>
}

// Inspect accepts an inspector function that has same arguments as the ChatRepo.CreateChat
func (mmCreateChat *mChatRepoMockCreateChat) Inspect(f func(ctx context.Context, in *model.CreateChatRequest)) *mChatRepoMockCreateChat <span class="cov0" title="0">{
        if mmCreateChat.mock.inspectFuncCreateChat != nil </span><span class="cov0" title="0">{
                mmCreateChat.mock.t.Fatalf("Inspect function is already set for ChatRepoMock.CreateChat")
        }</span>

        <span class="cov0" title="0">mmCreateChat.mock.inspectFuncCreateChat = f

        return mmCreateChat</span>
}

// Return sets up results that will be returned by ChatRepo.CreateChat
func (mmCreateChat *mChatRepoMockCreateChat) Return(id int64, err error) *ChatRepoMock <span class="cov8" title="1">{
        if mmCreateChat.mock.funcCreateChat != nil </span><span class="cov0" title="0">{
                mmCreateChat.mock.t.Fatalf("ChatRepoMock.CreateChat mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmCreateChat.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreateChat.defaultExpectation = &amp;ChatRepoMockCreateChatExpectation{mock: mmCreateChat.mock}
        }</span>
        <span class="cov8" title="1">mmCreateChat.defaultExpectation.results = &amp;ChatRepoMockCreateChatResults{id, err}
        return mmCreateChat.mock</span>
}

// Set uses given function f to mock the ChatRepo.CreateChat method
func (mmCreateChat *mChatRepoMockCreateChat) Set(f func(ctx context.Context, in *model.CreateChatRequest) (id int64, err error)) *ChatRepoMock <span class="cov0" title="0">{
        if mmCreateChat.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmCreateChat.mock.t.Fatalf("Default expectation is already set for the ChatRepo.CreateChat method")
        }</span>

        <span class="cov0" title="0">if len(mmCreateChat.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmCreateChat.mock.t.Fatalf("Some expectations are already set for the ChatRepo.CreateChat method")
        }</span>

        <span class="cov0" title="0">mmCreateChat.mock.funcCreateChat = f
        return mmCreateChat.mock</span>
}

// When sets expectation for the ChatRepo.CreateChat which will trigger the result defined by the following
// Then helper
func (mmCreateChat *mChatRepoMockCreateChat) When(ctx context.Context, in *model.CreateChatRequest) *ChatRepoMockCreateChatExpectation <span class="cov0" title="0">{
        if mmCreateChat.mock.funcCreateChat != nil </span><span class="cov0" title="0">{
                mmCreateChat.mock.t.Fatalf("ChatRepoMock.CreateChat mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;ChatRepoMockCreateChatExpectation{
                mock:   mmCreateChat.mock,
                params: &amp;ChatRepoMockCreateChatParams{ctx, in},
        }
        mmCreateChat.expectations = append(mmCreateChat.expectations, expectation)
        return expectation</span>
}

// Then sets up ChatRepo.CreateChat return parameters for the expectation previously defined by the When method
func (e *ChatRepoMockCreateChatExpectation) Then(id int64, err error) *ChatRepoMock <span class="cov0" title="0">{
        e.results = &amp;ChatRepoMockCreateChatResults{id, err}
        return e.mock
}</span>

// Times sets number of times ChatRepo.CreateChat should be invoked
func (mmCreateChat *mChatRepoMockCreateChat) Times(n uint64) *mChatRepoMockCreateChat <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmCreateChat.mock.t.Fatalf("Times of ChatRepoMock.CreateChat mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmCreateChat.expectedInvocations, n)
        return mmCreateChat</span>
}

func (mmCreateChat *mChatRepoMockCreateChat) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmCreateChat.expectations) == 0 &amp;&amp; mmCreateChat.defaultExpectation == nil &amp;&amp; mmCreateChat.mock.funcCreateChat == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">totalInvocations := mm_atomic.LoadUint64(&amp;mmCreateChat.mock.afterCreateChatCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmCreateChat.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// CreateChat implements repository.ChatRepo
func (mmCreateChat *ChatRepoMock) CreateChat(ctx context.Context, in *model.CreateChatRequest) (id int64, err error) <span class="cov8" title="1">{
        mm_atomic.AddUint64(&amp;mmCreateChat.beforeCreateChatCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmCreateChat.afterCreateChatCounter, 1)

        if mmCreateChat.inspectFuncCreateChat != nil </span><span class="cov0" title="0">{
                mmCreateChat.inspectFuncCreateChat(ctx, in)
        }</span>

        <span class="cov8" title="1">mm_params := ChatRepoMockCreateChatParams{ctx, in}

        // Record call args
        mmCreateChat.CreateChatMock.mutex.Lock()
        mmCreateChat.CreateChatMock.callArgs = append(mmCreateChat.CreateChatMock.callArgs, &amp;mm_params)
        mmCreateChat.CreateChatMock.mutex.Unlock()

        for _, e := range mmCreateChat.CreateChatMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.id, e.results.err
                }</span>
        }

        <span class="cov8" title="1">if mmCreateChat.CreateChatMock.defaultExpectation != nil </span><span class="cov8" title="1">{
                mm_atomic.AddUint64(&amp;mmCreateChat.CreateChatMock.defaultExpectation.Counter, 1)
                mm_want := mmCreateChat.CreateChatMock.defaultExpectation.params
                mm_want_ptrs := mmCreateChat.CreateChatMock.defaultExpectation.paramPtrs

                mm_got := ChatRepoMockCreateChatParams{ctx, in}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmCreateChat.t.Errorf("ChatRepoMock.CreateChat got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.in != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.in, mm_got.in) </span><span class="cov0" title="0">{
                                mmCreateChat.t.Errorf("ChatRepoMock.CreateChat got unexpected parameter in, want: %#v, got: %#v%s\n", *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
                        }</span>

                } else<span class="cov8" title="1"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmCreateChat.t.Errorf("ChatRepoMock.CreateChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov8" title="1">mm_results := mmCreateChat.CreateChatMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmCreateChat.t.Fatal("No results are set for the ChatRepoMock.CreateChat")
                }</span>
                <span class="cov8" title="1">return (*mm_results).id, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmCreateChat.funcCreateChat != nil </span><span class="cov0" title="0">{
                return mmCreateChat.funcCreateChat(ctx, in)
        }</span>
        <span class="cov0" title="0">mmCreateChat.t.Fatalf("Unexpected call to ChatRepoMock.CreateChat. %v %v", ctx, in)
        return</span>
}

// CreateChatAfterCounter returns a count of finished ChatRepoMock.CreateChat invocations
func (mmCreateChat *ChatRepoMock) CreateChatAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmCreateChat.afterCreateChatCounter)
}</span>

// CreateChatBeforeCounter returns a count of ChatRepoMock.CreateChat invocations
func (mmCreateChat *ChatRepoMock) CreateChatBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmCreateChat.beforeCreateChatCounter)
}</span>

// Calls returns a list of arguments used in each call to ChatRepoMock.CreateChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateChat *mChatRepoMockCreateChat) Calls() []*ChatRepoMockCreateChatParams <span class="cov0" title="0">{
        mmCreateChat.mutex.RLock()

        argCopy := make([]*ChatRepoMockCreateChatParams, len(mmCreateChat.callArgs))
        copy(argCopy, mmCreateChat.callArgs)

        mmCreateChat.mutex.RUnlock()

        return argCopy
}</span>

// MinimockCreateChatDone returns true if the count of the CreateChat invocations corresponds
// the number of defined expectations
func (m *ChatRepoMock) MinimockCreateChatDone() bool <span class="cov8" title="1">{
        if m.CreateChatMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.CreateChatMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.CreateChatMock.invocationsDone()</span>
}

// MinimockCreateChatInspect logs each unmet expectation
func (m *ChatRepoMock) MinimockCreateChatInspect() <span class="cov0" title="0">{
        for _, e := range m.CreateChatMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to ChatRepoMock.CreateChat with params: %#v", *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterCreateChatCounter := mm_atomic.LoadUint64(&amp;m.afterCreateChatCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.CreateChatMock.defaultExpectation != nil &amp;&amp; afterCreateChatCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.CreateChatMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to ChatRepoMock.CreateChat")
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to ChatRepoMock.CreateChat with params: %#v", *m.CreateChatMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcCreateChat != nil &amp;&amp; afterCreateChatCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Error("Expected call to ChatRepoMock.CreateChat")
        }</span>

        <span class="cov0" title="0">if !m.CreateChatMock.invocationsDone() &amp;&amp; afterCreateChatCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to ChatRepoMock.CreateChat but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.CreateChatMock.expectedInvocations), afterCreateChatCounter)
        }</span>
}

type mChatRepoMockDeleteChat struct {
        optional           bool
        mock               *ChatRepoMock
        defaultExpectation *ChatRepoMockDeleteChatExpectation
        expectations       []*ChatRepoMockDeleteChatExpectation

        callArgs []*ChatRepoMockDeleteChatParams
        mutex    sync.RWMutex

        expectedInvocations uint64
}

// ChatRepoMockDeleteChatExpectation specifies expectation struct of the ChatRepo.DeleteChat
type ChatRepoMockDeleteChatExpectation struct {
        mock      *ChatRepoMock
        params    *ChatRepoMockDeleteChatParams
        paramPtrs *ChatRepoMockDeleteChatParamPtrs
        results   *ChatRepoMockDeleteChatResults
        Counter   uint64
}

// ChatRepoMockDeleteChatParams contains parameters of the ChatRepo.DeleteChat
type ChatRepoMockDeleteChatParams struct {
        ctx context.Context
        id  int64
}

// ChatRepoMockDeleteChatParamPtrs contains pointers to parameters of the ChatRepo.DeleteChat
type ChatRepoMockDeleteChatParamPtrs struct {
        ctx *context.Context
        id  *int64
}

// ChatRepoMockDeleteChatResults contains results of the ChatRepo.DeleteChat
type ChatRepoMockDeleteChatResults struct {
        err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteChat *mChatRepoMockDeleteChat) Optional() *mChatRepoMockDeleteChat <span class="cov0" title="0">{
        mmDeleteChat.optional = true
        return mmDeleteChat
}</span>

// Expect sets up expected params for ChatRepo.DeleteChat
func (mmDeleteChat *mChatRepoMockDeleteChat) Expect(ctx context.Context, id int64) *mChatRepoMockDeleteChat <span class="cov8" title="1">{
        if mmDeleteChat.mock.funcDeleteChat != nil </span><span class="cov0" title="0">{
                mmDeleteChat.mock.t.Fatalf("ChatRepoMock.DeleteChat mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmDeleteChat.defaultExpectation == nil </span><span class="cov8" title="1">{
                mmDeleteChat.defaultExpectation = &amp;ChatRepoMockDeleteChatExpectation{}
        }</span>

        <span class="cov8" title="1">if mmDeleteChat.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmDeleteChat.mock.t.Fatalf("ChatRepoMock.DeleteChat mock is already set by ExpectParams functions")
        }</span>

        <span class="cov8" title="1">mmDeleteChat.defaultExpectation.params = &amp;ChatRepoMockDeleteChatParams{ctx, id}
        for _, e := range mmDeleteChat.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmDeleteChat.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmDeleteChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteChat.defaultExpectation.params)
                }</span>
        }

        <span class="cov8" title="1">return mmDeleteChat</span>
}

// ExpectCtxParam1 sets up expected param ctx for ChatRepo.DeleteChat
func (mmDeleteChat *mChatRepoMockDeleteChat) ExpectCtxParam1(ctx context.Context) *mChatRepoMockDeleteChat <span class="cov0" title="0">{
        if mmDeleteChat.mock.funcDeleteChat != nil </span><span class="cov0" title="0">{
                mmDeleteChat.mock.t.Fatalf("ChatRepoMock.DeleteChat mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmDeleteChat.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDeleteChat.defaultExpectation = &amp;ChatRepoMockDeleteChatExpectation{}
        }</span>

        <span class="cov0" title="0">if mmDeleteChat.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmDeleteChat.mock.t.Fatalf("ChatRepoMock.DeleteChat mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmDeleteChat.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmDeleteChat.defaultExpectation.paramPtrs = &amp;ChatRepoMockDeleteChatParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmDeleteChat.defaultExpectation.paramPtrs.ctx = &amp;ctx

        return mmDeleteChat</span>
}

// ExpectIdParam2 sets up expected param id for ChatRepo.DeleteChat
func (mmDeleteChat *mChatRepoMockDeleteChat) ExpectIdParam2(id int64) *mChatRepoMockDeleteChat <span class="cov0" title="0">{
        if mmDeleteChat.mock.funcDeleteChat != nil </span><span class="cov0" title="0">{
                mmDeleteChat.mock.t.Fatalf("ChatRepoMock.DeleteChat mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmDeleteChat.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDeleteChat.defaultExpectation = &amp;ChatRepoMockDeleteChatExpectation{}
        }</span>

        <span class="cov0" title="0">if mmDeleteChat.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmDeleteChat.mock.t.Fatalf("ChatRepoMock.DeleteChat mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmDeleteChat.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmDeleteChat.defaultExpectation.paramPtrs = &amp;ChatRepoMockDeleteChatParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmDeleteChat.defaultExpectation.paramPtrs.id = &amp;id

        return mmDeleteChat</span>
}

// Inspect accepts an inspector function that has same arguments as the ChatRepo.DeleteChat
func (mmDeleteChat *mChatRepoMockDeleteChat) Inspect(f func(ctx context.Context, id int64)) *mChatRepoMockDeleteChat <span class="cov0" title="0">{
        if mmDeleteChat.mock.inspectFuncDeleteChat != nil </span><span class="cov0" title="0">{
                mmDeleteChat.mock.t.Fatalf("Inspect function is already set for ChatRepoMock.DeleteChat")
        }</span>

        <span class="cov0" title="0">mmDeleteChat.mock.inspectFuncDeleteChat = f

        return mmDeleteChat</span>
}

// Return sets up results that will be returned by ChatRepo.DeleteChat
func (mmDeleteChat *mChatRepoMockDeleteChat) Return(err error) *ChatRepoMock <span class="cov8" title="1">{
        if mmDeleteChat.mock.funcDeleteChat != nil </span><span class="cov0" title="0">{
                mmDeleteChat.mock.t.Fatalf("ChatRepoMock.DeleteChat mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmDeleteChat.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDeleteChat.defaultExpectation = &amp;ChatRepoMockDeleteChatExpectation{mock: mmDeleteChat.mock}
        }</span>
        <span class="cov8" title="1">mmDeleteChat.defaultExpectation.results = &amp;ChatRepoMockDeleteChatResults{err}
        return mmDeleteChat.mock</span>
}

// Set uses given function f to mock the ChatRepo.DeleteChat method
func (mmDeleteChat *mChatRepoMockDeleteChat) Set(f func(ctx context.Context, id int64) (err error)) *ChatRepoMock <span class="cov0" title="0">{
        if mmDeleteChat.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmDeleteChat.mock.t.Fatalf("Default expectation is already set for the ChatRepo.DeleteChat method")
        }</span>

        <span class="cov0" title="0">if len(mmDeleteChat.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmDeleteChat.mock.t.Fatalf("Some expectations are already set for the ChatRepo.DeleteChat method")
        }</span>

        <span class="cov0" title="0">mmDeleteChat.mock.funcDeleteChat = f
        return mmDeleteChat.mock</span>
}

// When sets expectation for the ChatRepo.DeleteChat which will trigger the result defined by the following
// Then helper
func (mmDeleteChat *mChatRepoMockDeleteChat) When(ctx context.Context, id int64) *ChatRepoMockDeleteChatExpectation <span class="cov0" title="0">{
        if mmDeleteChat.mock.funcDeleteChat != nil </span><span class="cov0" title="0">{
                mmDeleteChat.mock.t.Fatalf("ChatRepoMock.DeleteChat mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;ChatRepoMockDeleteChatExpectation{
                mock:   mmDeleteChat.mock,
                params: &amp;ChatRepoMockDeleteChatParams{ctx, id},
        }
        mmDeleteChat.expectations = append(mmDeleteChat.expectations, expectation)
        return expectation</span>
}

// Then sets up ChatRepo.DeleteChat return parameters for the expectation previously defined by the When method
func (e *ChatRepoMockDeleteChatExpectation) Then(err error) *ChatRepoMock <span class="cov0" title="0">{
        e.results = &amp;ChatRepoMockDeleteChatResults{err}
        return e.mock
}</span>

// Times sets number of times ChatRepo.DeleteChat should be invoked
func (mmDeleteChat *mChatRepoMockDeleteChat) Times(n uint64) *mChatRepoMockDeleteChat <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmDeleteChat.mock.t.Fatalf("Times of ChatRepoMock.DeleteChat mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmDeleteChat.expectedInvocations, n)
        return mmDeleteChat</span>
}

func (mmDeleteChat *mChatRepoMockDeleteChat) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmDeleteChat.expectations) == 0 &amp;&amp; mmDeleteChat.defaultExpectation == nil &amp;&amp; mmDeleteChat.mock.funcDeleteChat == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">totalInvocations := mm_atomic.LoadUint64(&amp;mmDeleteChat.mock.afterDeleteChatCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmDeleteChat.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// DeleteChat implements repository.ChatRepo
func (mmDeleteChat *ChatRepoMock) DeleteChat(ctx context.Context, id int64) (err error) <span class="cov8" title="1">{
        mm_atomic.AddUint64(&amp;mmDeleteChat.beforeDeleteChatCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmDeleteChat.afterDeleteChatCounter, 1)

        if mmDeleteChat.inspectFuncDeleteChat != nil </span><span class="cov0" title="0">{
                mmDeleteChat.inspectFuncDeleteChat(ctx, id)
        }</span>

        <span class="cov8" title="1">mm_params := ChatRepoMockDeleteChatParams{ctx, id}

        // Record call args
        mmDeleteChat.DeleteChatMock.mutex.Lock()
        mmDeleteChat.DeleteChatMock.callArgs = append(mmDeleteChat.DeleteChatMock.callArgs, &amp;mm_params)
        mmDeleteChat.DeleteChatMock.mutex.Unlock()

        for _, e := range mmDeleteChat.DeleteChatMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov8" title="1">if mmDeleteChat.DeleteChatMock.defaultExpectation != nil </span><span class="cov8" title="1">{
                mm_atomic.AddUint64(&amp;mmDeleteChat.DeleteChatMock.defaultExpectation.Counter, 1)
                mm_want := mmDeleteChat.DeleteChatMock.defaultExpectation.params
                mm_want_ptrs := mmDeleteChat.DeleteChatMock.defaultExpectation.paramPtrs

                mm_got := ChatRepoMockDeleteChatParams{ctx, id}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmDeleteChat.t.Errorf("ChatRepoMock.DeleteChat got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.id != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.id, mm_got.id) </span><span class="cov0" title="0">{
                                mmDeleteChat.t.Errorf("ChatRepoMock.DeleteChat got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
                        }</span>

                } else<span class="cov8" title="1"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmDeleteChat.t.Errorf("ChatRepoMock.DeleteChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov8" title="1">mm_results := mmDeleteChat.DeleteChatMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmDeleteChat.t.Fatal("No results are set for the ChatRepoMock.DeleteChat")
                }</span>
                <span class="cov8" title="1">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmDeleteChat.funcDeleteChat != nil </span><span class="cov0" title="0">{
                return mmDeleteChat.funcDeleteChat(ctx, id)
        }</span>
        <span class="cov0" title="0">mmDeleteChat.t.Fatalf("Unexpected call to ChatRepoMock.DeleteChat. %v %v", ctx, id)
        return</span>
}

// DeleteChatAfterCounter returns a count of finished ChatRepoMock.DeleteChat invocations
func (mmDeleteChat *ChatRepoMock) DeleteChatAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmDeleteChat.afterDeleteChatCounter)
}</span>

// DeleteChatBeforeCounter returns a count of ChatRepoMock.DeleteChat invocations
func (mmDeleteChat *ChatRepoMock) DeleteChatBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmDeleteChat.beforeDeleteChatCounter)
}</span>

// Calls returns a list of arguments used in each call to ChatRepoMock.DeleteChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteChat *mChatRepoMockDeleteChat) Calls() []*ChatRepoMockDeleteChatParams <span class="cov0" title="0">{
        mmDeleteChat.mutex.RLock()

        argCopy := make([]*ChatRepoMockDeleteChatParams, len(mmDeleteChat.callArgs))
        copy(argCopy, mmDeleteChat.callArgs)

        mmDeleteChat.mutex.RUnlock()

        return argCopy
}</span>

// MinimockDeleteChatDone returns true if the count of the DeleteChat invocations corresponds
// the number of defined expectations
func (m *ChatRepoMock) MinimockDeleteChatDone() bool <span class="cov8" title="1">{
        if m.DeleteChatMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.DeleteChatMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.DeleteChatMock.invocationsDone()</span>
}

// MinimockDeleteChatInspect logs each unmet expectation
func (m *ChatRepoMock) MinimockDeleteChatInspect() <span class="cov0" title="0">{
        for _, e := range m.DeleteChatMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to ChatRepoMock.DeleteChat with params: %#v", *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterDeleteChatCounter := mm_atomic.LoadUint64(&amp;m.afterDeleteChatCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.DeleteChatMock.defaultExpectation != nil &amp;&amp; afterDeleteChatCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.DeleteChatMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to ChatRepoMock.DeleteChat")
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to ChatRepoMock.DeleteChat with params: %#v", *m.DeleteChatMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcDeleteChat != nil &amp;&amp; afterDeleteChatCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Error("Expected call to ChatRepoMock.DeleteChat")
        }</span>

        <span class="cov0" title="0">if !m.DeleteChatMock.invocationsDone() &amp;&amp; afterDeleteChatCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to ChatRepoMock.DeleteChat but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.DeleteChatMock.expectedInvocations), afterDeleteChatCounter)
        }</span>
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ChatRepoMock) MinimockFinish() <span class="cov8" title="1">{
        m.finishOnce.Do(func() </span><span class="cov8" title="1">{
                if !m.minimockDone() </span><span class="cov0" title="0">{
                        m.MinimockAddUsersToChatInspect()

                        m.MinimockCreateChatInspect()

                        m.MinimockDeleteChatInspect()
                }</span>
        })
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ChatRepoMock) MinimockWait(timeout mm_time.Duration) <span class="cov0" title="0">{
        timeoutCh := mm_time.After(timeout)
        for </span><span class="cov0" title="0">{
                if m.minimockDone() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-timeoutCh:<span class="cov0" title="0">
                        m.MinimockFinish()
                        return</span>
                case &lt;-mm_time.After(10 * mm_time.Millisecond):<span class="cov0" title="0"></span>
                }
        }
}

func (m *ChatRepoMock) minimockDone() bool <span class="cov8" title="1">{
        done := true
        return done &amp;&amp;
                m.MinimockAddUsersToChatDone() &amp;&amp;
                m.MinimockCreateChatDone() &amp;&amp;
                m.MinimockDeleteChatDone()
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">// Code generated by http://github.com/gojuno/minimock (v3.3.14). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/ArtEmerged/o_chat-server/internal/repository.MessageRepo -o message_repo_minimock.go -n MessageRepoMock -p mocks

import (
        "context"
        "sync"
        mm_atomic "sync/atomic"
        mm_time "time"

        "github.com/ArtEmerged/o_chat-server/internal/model"
        "github.com/gojuno/minimock/v3"
)

// MessageRepoMock implements repository.MessageRepo
type MessageRepoMock struct {
        t          minimock.Tester
        finishOnce sync.Once

        funcSendMessage          func(ctx context.Context, in *model.SendMessageRequest) (mp1 *model.Message, err error)
        inspectFuncSendMessage   func(ctx context.Context, in *model.SendMessageRequest)
        afterSendMessageCounter  uint64
        beforeSendMessageCounter uint64
        SendMessageMock          mMessageRepoMockSendMessage
}

// NewMessageRepoMock returns a mock for repository.MessageRepo
func NewMessageRepoMock(t minimock.Tester) *MessageRepoMock <span class="cov8" title="1">{
        m := &amp;MessageRepoMock{t: t}

        if controller, ok := t.(minimock.MockController); ok </span><span class="cov8" title="1">{
                controller.RegisterMocker(m)
        }</span>

        <span class="cov8" title="1">m.SendMessageMock = mMessageRepoMockSendMessage{mock: m}
        m.SendMessageMock.callArgs = []*MessageRepoMockSendMessageParams{}

        t.Cleanup(m.MinimockFinish)

        return m</span>
}

type mMessageRepoMockSendMessage struct {
        optional           bool
        mock               *MessageRepoMock
        defaultExpectation *MessageRepoMockSendMessageExpectation
        expectations       []*MessageRepoMockSendMessageExpectation

        callArgs []*MessageRepoMockSendMessageParams
        mutex    sync.RWMutex

        expectedInvocations uint64
}

// MessageRepoMockSendMessageExpectation specifies expectation struct of the MessageRepo.SendMessage
type MessageRepoMockSendMessageExpectation struct {
        mock      *MessageRepoMock
        params    *MessageRepoMockSendMessageParams
        paramPtrs *MessageRepoMockSendMessageParamPtrs
        results   *MessageRepoMockSendMessageResults
        Counter   uint64
}

// MessageRepoMockSendMessageParams contains parameters of the MessageRepo.SendMessage
type MessageRepoMockSendMessageParams struct {
        ctx context.Context
        in  *model.SendMessageRequest
}

// MessageRepoMockSendMessageParamPtrs contains pointers to parameters of the MessageRepo.SendMessage
type MessageRepoMockSendMessageParamPtrs struct {
        ctx *context.Context
        in  **model.SendMessageRequest
}

// MessageRepoMockSendMessageResults contains results of the MessageRepo.SendMessage
type MessageRepoMockSendMessageResults struct {
        mp1 *model.Message
        err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSendMessage *mMessageRepoMockSendMessage) Optional() *mMessageRepoMockSendMessage <span class="cov0" title="0">{
        mmSendMessage.optional = true
        return mmSendMessage
}</span>

// Expect sets up expected params for MessageRepo.SendMessage
func (mmSendMessage *mMessageRepoMockSendMessage) Expect(ctx context.Context, in *model.SendMessageRequest) *mMessageRepoMockSendMessage <span class="cov8" title="1">{
        if mmSendMessage.mock.funcSendMessage != nil </span><span class="cov0" title="0">{
                mmSendMessage.mock.t.Fatalf("MessageRepoMock.SendMessage mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmSendMessage.defaultExpectation == nil </span><span class="cov8" title="1">{
                mmSendMessage.defaultExpectation = &amp;MessageRepoMockSendMessageExpectation{}
        }</span>

        <span class="cov8" title="1">if mmSendMessage.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmSendMessage.mock.t.Fatalf("MessageRepoMock.SendMessage mock is already set by ExpectParams functions")
        }</span>

        <span class="cov8" title="1">mmSendMessage.defaultExpectation.params = &amp;MessageRepoMockSendMessageParams{ctx, in}
        for _, e := range mmSendMessage.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmSendMessage.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmSendMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendMessage.defaultExpectation.params)
                }</span>
        }

        <span class="cov8" title="1">return mmSendMessage</span>
}

// ExpectCtxParam1 sets up expected param ctx for MessageRepo.SendMessage
func (mmSendMessage *mMessageRepoMockSendMessage) ExpectCtxParam1(ctx context.Context) *mMessageRepoMockSendMessage <span class="cov0" title="0">{
        if mmSendMessage.mock.funcSendMessage != nil </span><span class="cov0" title="0">{
                mmSendMessage.mock.t.Fatalf("MessageRepoMock.SendMessage mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmSendMessage.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmSendMessage.defaultExpectation = &amp;MessageRepoMockSendMessageExpectation{}
        }</span>

        <span class="cov0" title="0">if mmSendMessage.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmSendMessage.mock.t.Fatalf("MessageRepoMock.SendMessage mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmSendMessage.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmSendMessage.defaultExpectation.paramPtrs = &amp;MessageRepoMockSendMessageParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmSendMessage.defaultExpectation.paramPtrs.ctx = &amp;ctx

        return mmSendMessage</span>
}

// ExpectInParam2 sets up expected param in for MessageRepo.SendMessage
func (mmSendMessage *mMessageRepoMockSendMessage) ExpectInParam2(in *model.SendMessageRequest) *mMessageRepoMockSendMessage <span class="cov0" title="0">{
        if mmSendMessage.mock.funcSendMessage != nil </span><span class="cov0" title="0">{
                mmSendMessage.mock.t.Fatalf("MessageRepoMock.SendMessage mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmSendMessage.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmSendMessage.defaultExpectation = &amp;MessageRepoMockSendMessageExpectation{}
        }</span>

        <span class="cov0" title="0">if mmSendMessage.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmSendMessage.mock.t.Fatalf("MessageRepoMock.SendMessage mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmSendMessage.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmSendMessage.defaultExpectation.paramPtrs = &amp;MessageRepoMockSendMessageParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmSendMessage.defaultExpectation.paramPtrs.in = &amp;in

        return mmSendMessage</span>
}

// Inspect accepts an inspector function that has same arguments as the MessageRepo.SendMessage
func (mmSendMessage *mMessageRepoMockSendMessage) Inspect(f func(ctx context.Context, in *model.SendMessageRequest)) *mMessageRepoMockSendMessage <span class="cov0" title="0">{
        if mmSendMessage.mock.inspectFuncSendMessage != nil </span><span class="cov0" title="0">{
                mmSendMessage.mock.t.Fatalf("Inspect function is already set for MessageRepoMock.SendMessage")
        }</span>

        <span class="cov0" title="0">mmSendMessage.mock.inspectFuncSendMessage = f

        return mmSendMessage</span>
}

// Return sets up results that will be returned by MessageRepo.SendMessage
func (mmSendMessage *mMessageRepoMockSendMessage) Return(mp1 *model.Message, err error) *MessageRepoMock <span class="cov8" title="1">{
        if mmSendMessage.mock.funcSendMessage != nil </span><span class="cov0" title="0">{
                mmSendMessage.mock.t.Fatalf("MessageRepoMock.SendMessage mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmSendMessage.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmSendMessage.defaultExpectation = &amp;MessageRepoMockSendMessageExpectation{mock: mmSendMessage.mock}
        }</span>
        <span class="cov8" title="1">mmSendMessage.defaultExpectation.results = &amp;MessageRepoMockSendMessageResults{mp1, err}
        return mmSendMessage.mock</span>
}

// Set uses given function f to mock the MessageRepo.SendMessage method
func (mmSendMessage *mMessageRepoMockSendMessage) Set(f func(ctx context.Context, in *model.SendMessageRequest) (mp1 *model.Message, err error)) *MessageRepoMock <span class="cov0" title="0">{
        if mmSendMessage.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmSendMessage.mock.t.Fatalf("Default expectation is already set for the MessageRepo.SendMessage method")
        }</span>

        <span class="cov0" title="0">if len(mmSendMessage.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmSendMessage.mock.t.Fatalf("Some expectations are already set for the MessageRepo.SendMessage method")
        }</span>

        <span class="cov0" title="0">mmSendMessage.mock.funcSendMessage = f
        return mmSendMessage.mock</span>
}

// When sets expectation for the MessageRepo.SendMessage which will trigger the result defined by the following
// Then helper
func (mmSendMessage *mMessageRepoMockSendMessage) When(ctx context.Context, in *model.SendMessageRequest) *MessageRepoMockSendMessageExpectation <span class="cov0" title="0">{
        if mmSendMessage.mock.funcSendMessage != nil </span><span class="cov0" title="0">{
                mmSendMessage.mock.t.Fatalf("MessageRepoMock.SendMessage mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;MessageRepoMockSendMessageExpectation{
                mock:   mmSendMessage.mock,
                params: &amp;MessageRepoMockSendMessageParams{ctx, in},
        }
        mmSendMessage.expectations = append(mmSendMessage.expectations, expectation)
        return expectation</span>
}

// Then sets up MessageRepo.SendMessage return parameters for the expectation previously defined by the When method
func (e *MessageRepoMockSendMessageExpectation) Then(mp1 *model.Message, err error) *MessageRepoMock <span class="cov0" title="0">{
        e.results = &amp;MessageRepoMockSendMessageResults{mp1, err}
        return e.mock
}</span>

// Times sets number of times MessageRepo.SendMessage should be invoked
func (mmSendMessage *mMessageRepoMockSendMessage) Times(n uint64) *mMessageRepoMockSendMessage <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmSendMessage.mock.t.Fatalf("Times of MessageRepoMock.SendMessage mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmSendMessage.expectedInvocations, n)
        return mmSendMessage</span>
}

func (mmSendMessage *mMessageRepoMockSendMessage) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmSendMessage.expectations) == 0 &amp;&amp; mmSendMessage.defaultExpectation == nil &amp;&amp; mmSendMessage.mock.funcSendMessage == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">totalInvocations := mm_atomic.LoadUint64(&amp;mmSendMessage.mock.afterSendMessageCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmSendMessage.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// SendMessage implements repository.MessageRepo
func (mmSendMessage *MessageRepoMock) SendMessage(ctx context.Context, in *model.SendMessageRequest) (mp1 *model.Message, err error) <span class="cov8" title="1">{
        mm_atomic.AddUint64(&amp;mmSendMessage.beforeSendMessageCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmSendMessage.afterSendMessageCounter, 1)

        if mmSendMessage.inspectFuncSendMessage != nil </span><span class="cov0" title="0">{
                mmSendMessage.inspectFuncSendMessage(ctx, in)
        }</span>

        <span class="cov8" title="1">mm_params := MessageRepoMockSendMessageParams{ctx, in}

        // Record call args
        mmSendMessage.SendMessageMock.mutex.Lock()
        mmSendMessage.SendMessageMock.callArgs = append(mmSendMessage.SendMessageMock.callArgs, &amp;mm_params)
        mmSendMessage.SendMessageMock.mutex.Unlock()

        for _, e := range mmSendMessage.SendMessageMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.mp1, e.results.err
                }</span>
        }

        <span class="cov8" title="1">if mmSendMessage.SendMessageMock.defaultExpectation != nil </span><span class="cov8" title="1">{
                mm_atomic.AddUint64(&amp;mmSendMessage.SendMessageMock.defaultExpectation.Counter, 1)
                mm_want := mmSendMessage.SendMessageMock.defaultExpectation.params
                mm_want_ptrs := mmSendMessage.SendMessageMock.defaultExpectation.paramPtrs

                mm_got := MessageRepoMockSendMessageParams{ctx, in}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmSendMessage.t.Errorf("MessageRepoMock.SendMessage got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.in != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.in, mm_got.in) </span><span class="cov0" title="0">{
                                mmSendMessage.t.Errorf("MessageRepoMock.SendMessage got unexpected parameter in, want: %#v, got: %#v%s\n", *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
                        }</span>

                } else<span class="cov8" title="1"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmSendMessage.t.Errorf("MessageRepoMock.SendMessage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov8" title="1">mm_results := mmSendMessage.SendMessageMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmSendMessage.t.Fatal("No results are set for the MessageRepoMock.SendMessage")
                }</span>
                <span class="cov8" title="1">return (*mm_results).mp1, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmSendMessage.funcSendMessage != nil </span><span class="cov0" title="0">{
                return mmSendMessage.funcSendMessage(ctx, in)
        }</span>
        <span class="cov0" title="0">mmSendMessage.t.Fatalf("Unexpected call to MessageRepoMock.SendMessage. %v %v", ctx, in)
        return</span>
}

// SendMessageAfterCounter returns a count of finished MessageRepoMock.SendMessage invocations
func (mmSendMessage *MessageRepoMock) SendMessageAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmSendMessage.afterSendMessageCounter)
}</span>

// SendMessageBeforeCounter returns a count of MessageRepoMock.SendMessage invocations
func (mmSendMessage *MessageRepoMock) SendMessageBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmSendMessage.beforeSendMessageCounter)
}</span>

// Calls returns a list of arguments used in each call to MessageRepoMock.SendMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendMessage *mMessageRepoMockSendMessage) Calls() []*MessageRepoMockSendMessageParams <span class="cov0" title="0">{
        mmSendMessage.mutex.RLock()

        argCopy := make([]*MessageRepoMockSendMessageParams, len(mmSendMessage.callArgs))
        copy(argCopy, mmSendMessage.callArgs)

        mmSendMessage.mutex.RUnlock()

        return argCopy
}</span>

// MinimockSendMessageDone returns true if the count of the SendMessage invocations corresponds
// the number of defined expectations
func (m *MessageRepoMock) MinimockSendMessageDone() bool <span class="cov8" title="1">{
        if m.SendMessageMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.SendMessageMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.SendMessageMock.invocationsDone()</span>
}

// MinimockSendMessageInspect logs each unmet expectation
func (m *MessageRepoMock) MinimockSendMessageInspect() <span class="cov0" title="0">{
        for _, e := range m.SendMessageMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to MessageRepoMock.SendMessage with params: %#v", *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterSendMessageCounter := mm_atomic.LoadUint64(&amp;m.afterSendMessageCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.SendMessageMock.defaultExpectation != nil &amp;&amp; afterSendMessageCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.SendMessageMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to MessageRepoMock.SendMessage")
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to MessageRepoMock.SendMessage with params: %#v", *m.SendMessageMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcSendMessage != nil &amp;&amp; afterSendMessageCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Error("Expected call to MessageRepoMock.SendMessage")
        }</span>

        <span class="cov0" title="0">if !m.SendMessageMock.invocationsDone() &amp;&amp; afterSendMessageCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to MessageRepoMock.SendMessage but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.SendMessageMock.expectedInvocations), afterSendMessageCounter)
        }</span>
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *MessageRepoMock) MinimockFinish() <span class="cov8" title="1">{
        m.finishOnce.Do(func() </span><span class="cov8" title="1">{
                if !m.minimockDone() </span><span class="cov0" title="0">{
                        m.MinimockSendMessageInspect()
                }</span>
        })
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *MessageRepoMock) MinimockWait(timeout mm_time.Duration) <span class="cov0" title="0">{
        timeoutCh := mm_time.After(timeout)
        for </span><span class="cov0" title="0">{
                if m.minimockDone() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-timeoutCh:<span class="cov0" title="0">
                        m.MinimockFinish()
                        return</span>
                case &lt;-mm_time.After(10 * mm_time.Millisecond):<span class="cov0" title="0"></span>
                }
        }
}

func (m *MessageRepoMock) minimockDone() bool <span class="cov8" title="1">{
        done := true
        return done &amp;&amp;
                m.MinimockSendMessageDone()
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package chat

import (
        "context"
        "log"

        "github.com/ArtEmerged/o_chat-server/internal/model"
)

// CreateChat creates new chat by chat name and creator id with user ids.
func (s *chatService) CreateChat(ctx context.Context, in *model.CreateChatRequest) (id int64, err error) <span class="cov8" title="1">{

        if err = in.Validate(); err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>

        // add the chat owner to the list of participants
        <span class="cov8" title="1">in.UserIDs = append(in.UserIDs, in.CreatorID)

        // remove duplicates
        in.UserIDs = uniqueSliceInt64(in.UserIDs)

        err = s.txManager.ReadCommitted(ctx, func(ctx context.Context) error </span><span class="cov8" title="1">{
                var errTx error

                id, errTx = s.repo.CreateChat(ctx, in)
                if errTx != nil </span><span class="cov8" title="1">{
                        return errTx
                }</span>

                <span class="cov8" title="1">errTx = s.repo.AddUsersToChat(ctx, id, in.UserIDs)
                if errTx != nil </span><span class="cov8" title="1">{
                        return errTx
                }</span>

                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return -1, err
        }</span>

        <span class="cov8" title="1">newChat := &amp;model.Chat{
                ID:        id,
                ChatName:  in.ChatName,
                CreatorID: in.CreatorID,
                UserIDs:   in.UserIDs,
        }

        err = s.cache.Set(ctx, model.ChatCacheKey(id), newChat, 0)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("WARN: failed to set chat in cache: %s\n", err.Error())
        }</span>

        <span class="cov8" title="1">return id, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package chat

import (
        "context"
        "log"

        "github.com/ArtEmerged/o_chat-server/internal/model"
)

// DeleteChat deletes chat by id.
func (s *chatService) DeleteChat(ctx context.Context, id int64) error <span class="cov8" title="1">{
        err := s.repo.DeleteChat(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">err = s.cache.Del(ctx, model.ChatCacheKey(id))
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("WARN: failed to delete chat in cache: %s\n", err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package chat

import "sort"

func uniqueSliceInt64(s []int64) []int64 <span class="cov8" title="1">{
        uniqueUserIDs := map[int64]struct{}{}

        for _, userID := range s </span><span class="cov8" title="1">{
                uniqueUserIDs[userID] = struct{}{}
        }</span>

        <span class="cov8" title="1">result := make([]int64, 0, len(uniqueUserIDs))

        for userID := range uniqueUserIDs </span><span class="cov8" title="1">{
                result = append(result, userID)
        }</span>

        <span class="cov8" title="1">sort.Slice(result, func(i, j int) bool </span><span class="cov8" title="1">{ return result[i] &lt; result[j] }</span>)
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package chat

import (
        "github.com/ArtEmerged/library/client/cache"
        "github.com/ArtEmerged/library/client/db"

        "github.com/ArtEmerged/o_chat-server/internal/repository"
        "github.com/ArtEmerged/o_chat-server/internal/service"
)

type chatService struct {
        repo      repository.ChatRepo
        txManager db.TxManager
        cache     cache.Cache
}

// New returns new chat service
func New(repo repository.ChatRepo, txManager db.TxManager, cache cache.Cache) service.ChatService <span class="cov8" title="1">{
        return &amp;chatService{
                repo:      repo,
                txManager: txManager,
                cache:     cache,
        }
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package support

import (
        "context"

        "github.com/ArtEmerged/library/client/db"
)

type txManagerFake struct {
}

// NewTxManagerFake fake tx manager
func NewTxManagerFake() db.TxManager <span class="cov8" title="1">{
        return &amp;txManagerFake{}
}</span>

func (tx *txManagerFake) ReadCommitted(ctx context.Context, f db.Handler) error <span class="cov8" title="1">{
        return f(ctx)
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package message

import (
        "context"
        "log"
        "strconv"
        "time"

        "github.com/ArtEmerged/o_chat-server/internal/model"
)

// SendMessage sends message to chat by chat id and from user id.
func (s *messageService) SendMessage(ctx context.Context, in *model.SendMessageRequest) error <span class="cov8" title="1">{
        if err := in.Validate(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">message, err := s.repo.SendMessage(ctx, in)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">msgIDStr := strconv.FormatInt(message.ID, 10)

        err = s.cache.HSet(ctx, model.CreateMessageKey(in.ChatID), msgIDStr, message, time.Hour*1)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("WARN: failed to save message in cache: %s\n", err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package message

import (
        "github.com/ArtEmerged/library/client/cache"
        "github.com/ArtEmerged/library/client/db"

        "github.com/ArtEmerged/o_chat-server/internal/repository"
        "github.com/ArtEmerged/o_chat-server/internal/service"
)

type messageService struct {
        repo      repository.MessageRepo
        cache     cache.Cache
        txManager db.TxManager
}

// New returns new chat service
func New(repo repository.MessageRepo, cache cache.Cache, txManager db.TxManager) service.MessageService <span class="cov8" title="1">{

        return &amp;messageService{
                repo:      repo,
                cache:     cache,
                txManager: txManager,
        }
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">// Code generated by http://github.com/gojuno/minimock (v3.3.14). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/ArtEmerged/o_chat-server/internal/service.ChatService -o chat_service_minimock.go -n ChatServiceMock -p mocks

import (
        "context"
        "sync"
        mm_atomic "sync/atomic"
        mm_time "time"

        "github.com/ArtEmerged/o_chat-server/internal/model"
        "github.com/gojuno/minimock/v3"
)

// ChatServiceMock implements service.ChatService
type ChatServiceMock struct {
        t          minimock.Tester
        finishOnce sync.Once

        funcCreateChat          func(ctx context.Context, in *model.CreateChatRequest) (id int64, err error)
        inspectFuncCreateChat   func(ctx context.Context, in *model.CreateChatRequest)
        afterCreateChatCounter  uint64
        beforeCreateChatCounter uint64
        CreateChatMock          mChatServiceMockCreateChat

        funcDeleteChat          func(ctx context.Context, id int64) (err error)
        inspectFuncDeleteChat   func(ctx context.Context, id int64)
        afterDeleteChatCounter  uint64
        beforeDeleteChatCounter uint64
        DeleteChatMock          mChatServiceMockDeleteChat
}

// NewChatServiceMock returns a mock for service.ChatService
func NewChatServiceMock(t minimock.Tester) *ChatServiceMock <span class="cov8" title="1">{
        m := &amp;ChatServiceMock{t: t}

        if controller, ok := t.(minimock.MockController); ok </span><span class="cov8" title="1">{
                controller.RegisterMocker(m)
        }</span>

        <span class="cov8" title="1">m.CreateChatMock = mChatServiceMockCreateChat{mock: m}
        m.CreateChatMock.callArgs = []*ChatServiceMockCreateChatParams{}

        m.DeleteChatMock = mChatServiceMockDeleteChat{mock: m}
        m.DeleteChatMock.callArgs = []*ChatServiceMockDeleteChatParams{}

        t.Cleanup(m.MinimockFinish)

        return m</span>
}

type mChatServiceMockCreateChat struct {
        optional           bool
        mock               *ChatServiceMock
        defaultExpectation *ChatServiceMockCreateChatExpectation
        expectations       []*ChatServiceMockCreateChatExpectation

        callArgs []*ChatServiceMockCreateChatParams
        mutex    sync.RWMutex

        expectedInvocations uint64
}

// ChatServiceMockCreateChatExpectation specifies expectation struct of the ChatService.CreateChat
type ChatServiceMockCreateChatExpectation struct {
        mock      *ChatServiceMock
        params    *ChatServiceMockCreateChatParams
        paramPtrs *ChatServiceMockCreateChatParamPtrs
        results   *ChatServiceMockCreateChatResults
        Counter   uint64
}

// ChatServiceMockCreateChatParams contains parameters of the ChatService.CreateChat
type ChatServiceMockCreateChatParams struct {
        ctx context.Context
        in  *model.CreateChatRequest
}

// ChatServiceMockCreateChatParamPtrs contains pointers to parameters of the ChatService.CreateChat
type ChatServiceMockCreateChatParamPtrs struct {
        ctx *context.Context
        in  **model.CreateChatRequest
}

// ChatServiceMockCreateChatResults contains results of the ChatService.CreateChat
type ChatServiceMockCreateChatResults struct {
        id  int64
        err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateChat *mChatServiceMockCreateChat) Optional() *mChatServiceMockCreateChat <span class="cov0" title="0">{
        mmCreateChat.optional = true
        return mmCreateChat
}</span>

// Expect sets up expected params for ChatService.CreateChat
func (mmCreateChat *mChatServiceMockCreateChat) Expect(ctx context.Context, in *model.CreateChatRequest) *mChatServiceMockCreateChat <span class="cov8" title="1">{
        if mmCreateChat.mock.funcCreateChat != nil </span><span class="cov0" title="0">{
                mmCreateChat.mock.t.Fatalf("ChatServiceMock.CreateChat mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmCreateChat.defaultExpectation == nil </span><span class="cov8" title="1">{
                mmCreateChat.defaultExpectation = &amp;ChatServiceMockCreateChatExpectation{}
        }</span>

        <span class="cov8" title="1">if mmCreateChat.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmCreateChat.mock.t.Fatalf("ChatServiceMock.CreateChat mock is already set by ExpectParams functions")
        }</span>

        <span class="cov8" title="1">mmCreateChat.defaultExpectation.params = &amp;ChatServiceMockCreateChatParams{ctx, in}
        for _, e := range mmCreateChat.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmCreateChat.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmCreateChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateChat.defaultExpectation.params)
                }</span>
        }

        <span class="cov8" title="1">return mmCreateChat</span>
}

// ExpectCtxParam1 sets up expected param ctx for ChatService.CreateChat
func (mmCreateChat *mChatServiceMockCreateChat) ExpectCtxParam1(ctx context.Context) *mChatServiceMockCreateChat <span class="cov0" title="0">{
        if mmCreateChat.mock.funcCreateChat != nil </span><span class="cov0" title="0">{
                mmCreateChat.mock.t.Fatalf("ChatServiceMock.CreateChat mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreateChat.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreateChat.defaultExpectation = &amp;ChatServiceMockCreateChatExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreateChat.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmCreateChat.mock.t.Fatalf("ChatServiceMock.CreateChat mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmCreateChat.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmCreateChat.defaultExpectation.paramPtrs = &amp;ChatServiceMockCreateChatParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmCreateChat.defaultExpectation.paramPtrs.ctx = &amp;ctx

        return mmCreateChat</span>
}

// ExpectInParam2 sets up expected param in for ChatService.CreateChat
func (mmCreateChat *mChatServiceMockCreateChat) ExpectInParam2(in *model.CreateChatRequest) *mChatServiceMockCreateChat <span class="cov0" title="0">{
        if mmCreateChat.mock.funcCreateChat != nil </span><span class="cov0" title="0">{
                mmCreateChat.mock.t.Fatalf("ChatServiceMock.CreateChat mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreateChat.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreateChat.defaultExpectation = &amp;ChatServiceMockCreateChatExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreateChat.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmCreateChat.mock.t.Fatalf("ChatServiceMock.CreateChat mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmCreateChat.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmCreateChat.defaultExpectation.paramPtrs = &amp;ChatServiceMockCreateChatParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmCreateChat.defaultExpectation.paramPtrs.in = &amp;in

        return mmCreateChat</span>
}

// Inspect accepts an inspector function that has same arguments as the ChatService.CreateChat
func (mmCreateChat *mChatServiceMockCreateChat) Inspect(f func(ctx context.Context, in *model.CreateChatRequest)) *mChatServiceMockCreateChat <span class="cov0" title="0">{
        if mmCreateChat.mock.inspectFuncCreateChat != nil </span><span class="cov0" title="0">{
                mmCreateChat.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.CreateChat")
        }</span>

        <span class="cov0" title="0">mmCreateChat.mock.inspectFuncCreateChat = f

        return mmCreateChat</span>
}

// Return sets up results that will be returned by ChatService.CreateChat
func (mmCreateChat *mChatServiceMockCreateChat) Return(id int64, err error) *ChatServiceMock <span class="cov8" title="1">{
        if mmCreateChat.mock.funcCreateChat != nil </span><span class="cov0" title="0">{
                mmCreateChat.mock.t.Fatalf("ChatServiceMock.CreateChat mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmCreateChat.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreateChat.defaultExpectation = &amp;ChatServiceMockCreateChatExpectation{mock: mmCreateChat.mock}
        }</span>
        <span class="cov8" title="1">mmCreateChat.defaultExpectation.results = &amp;ChatServiceMockCreateChatResults{id, err}
        return mmCreateChat.mock</span>
}

// Set uses given function f to mock the ChatService.CreateChat method
func (mmCreateChat *mChatServiceMockCreateChat) Set(f func(ctx context.Context, in *model.CreateChatRequest) (id int64, err error)) *ChatServiceMock <span class="cov0" title="0">{
        if mmCreateChat.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmCreateChat.mock.t.Fatalf("Default expectation is already set for the ChatService.CreateChat method")
        }</span>

        <span class="cov0" title="0">if len(mmCreateChat.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmCreateChat.mock.t.Fatalf("Some expectations are already set for the ChatService.CreateChat method")
        }</span>

        <span class="cov0" title="0">mmCreateChat.mock.funcCreateChat = f
        return mmCreateChat.mock</span>
}

// When sets expectation for the ChatService.CreateChat which will trigger the result defined by the following
// Then helper
func (mmCreateChat *mChatServiceMockCreateChat) When(ctx context.Context, in *model.CreateChatRequest) *ChatServiceMockCreateChatExpectation <span class="cov0" title="0">{
        if mmCreateChat.mock.funcCreateChat != nil </span><span class="cov0" title="0">{
                mmCreateChat.mock.t.Fatalf("ChatServiceMock.CreateChat mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;ChatServiceMockCreateChatExpectation{
                mock:   mmCreateChat.mock,
                params: &amp;ChatServiceMockCreateChatParams{ctx, in},
        }
        mmCreateChat.expectations = append(mmCreateChat.expectations, expectation)
        return expectation</span>
}

// Then sets up ChatService.CreateChat return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockCreateChatExpectation) Then(id int64, err error) *ChatServiceMock <span class="cov0" title="0">{
        e.results = &amp;ChatServiceMockCreateChatResults{id, err}
        return e.mock
}</span>

// Times sets number of times ChatService.CreateChat should be invoked
func (mmCreateChat *mChatServiceMockCreateChat) Times(n uint64) *mChatServiceMockCreateChat <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmCreateChat.mock.t.Fatalf("Times of ChatServiceMock.CreateChat mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmCreateChat.expectedInvocations, n)
        return mmCreateChat</span>
}

func (mmCreateChat *mChatServiceMockCreateChat) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmCreateChat.expectations) == 0 &amp;&amp; mmCreateChat.defaultExpectation == nil &amp;&amp; mmCreateChat.mock.funcCreateChat == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">totalInvocations := mm_atomic.LoadUint64(&amp;mmCreateChat.mock.afterCreateChatCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmCreateChat.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// CreateChat implements service.ChatService
func (mmCreateChat *ChatServiceMock) CreateChat(ctx context.Context, in *model.CreateChatRequest) (id int64, err error) <span class="cov8" title="1">{
        mm_atomic.AddUint64(&amp;mmCreateChat.beforeCreateChatCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmCreateChat.afterCreateChatCounter, 1)

        if mmCreateChat.inspectFuncCreateChat != nil </span><span class="cov0" title="0">{
                mmCreateChat.inspectFuncCreateChat(ctx, in)
        }</span>

        <span class="cov8" title="1">mm_params := ChatServiceMockCreateChatParams{ctx, in}

        // Record call args
        mmCreateChat.CreateChatMock.mutex.Lock()
        mmCreateChat.CreateChatMock.callArgs = append(mmCreateChat.CreateChatMock.callArgs, &amp;mm_params)
        mmCreateChat.CreateChatMock.mutex.Unlock()

        for _, e := range mmCreateChat.CreateChatMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.id, e.results.err
                }</span>
        }

        <span class="cov8" title="1">if mmCreateChat.CreateChatMock.defaultExpectation != nil </span><span class="cov8" title="1">{
                mm_atomic.AddUint64(&amp;mmCreateChat.CreateChatMock.defaultExpectation.Counter, 1)
                mm_want := mmCreateChat.CreateChatMock.defaultExpectation.params
                mm_want_ptrs := mmCreateChat.CreateChatMock.defaultExpectation.paramPtrs

                mm_got := ChatServiceMockCreateChatParams{ctx, in}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmCreateChat.t.Errorf("ChatServiceMock.CreateChat got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.in != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.in, mm_got.in) </span><span class="cov0" title="0">{
                                mmCreateChat.t.Errorf("ChatServiceMock.CreateChat got unexpected parameter in, want: %#v, got: %#v%s\n", *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
                        }</span>

                } else<span class="cov8" title="1"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmCreateChat.t.Errorf("ChatServiceMock.CreateChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov8" title="1">mm_results := mmCreateChat.CreateChatMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmCreateChat.t.Fatal("No results are set for the ChatServiceMock.CreateChat")
                }</span>
                <span class="cov8" title="1">return (*mm_results).id, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmCreateChat.funcCreateChat != nil </span><span class="cov0" title="0">{
                return mmCreateChat.funcCreateChat(ctx, in)
        }</span>
        <span class="cov0" title="0">mmCreateChat.t.Fatalf("Unexpected call to ChatServiceMock.CreateChat. %v %v", ctx, in)
        return</span>
}

// CreateChatAfterCounter returns a count of finished ChatServiceMock.CreateChat invocations
func (mmCreateChat *ChatServiceMock) CreateChatAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmCreateChat.afterCreateChatCounter)
}</span>

// CreateChatBeforeCounter returns a count of ChatServiceMock.CreateChat invocations
func (mmCreateChat *ChatServiceMock) CreateChatBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmCreateChat.beforeCreateChatCounter)
}</span>

// Calls returns a list of arguments used in each call to ChatServiceMock.CreateChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateChat *mChatServiceMockCreateChat) Calls() []*ChatServiceMockCreateChatParams <span class="cov0" title="0">{
        mmCreateChat.mutex.RLock()

        argCopy := make([]*ChatServiceMockCreateChatParams, len(mmCreateChat.callArgs))
        copy(argCopy, mmCreateChat.callArgs)

        mmCreateChat.mutex.RUnlock()

        return argCopy
}</span>

// MinimockCreateChatDone returns true if the count of the CreateChat invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockCreateChatDone() bool <span class="cov8" title="1">{
        if m.CreateChatMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.CreateChatMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.CreateChatMock.invocationsDone()</span>
}

// MinimockCreateChatInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockCreateChatInspect() <span class="cov0" title="0">{
        for _, e := range m.CreateChatMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to ChatServiceMock.CreateChat with params: %#v", *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterCreateChatCounter := mm_atomic.LoadUint64(&amp;m.afterCreateChatCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.CreateChatMock.defaultExpectation != nil &amp;&amp; afterCreateChatCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.CreateChatMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to ChatServiceMock.CreateChat")
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to ChatServiceMock.CreateChat with params: %#v", *m.CreateChatMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcCreateChat != nil &amp;&amp; afterCreateChatCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Error("Expected call to ChatServiceMock.CreateChat")
        }</span>

        <span class="cov0" title="0">if !m.CreateChatMock.invocationsDone() &amp;&amp; afterCreateChatCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to ChatServiceMock.CreateChat but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.CreateChatMock.expectedInvocations), afterCreateChatCounter)
        }</span>
}

type mChatServiceMockDeleteChat struct {
        optional           bool
        mock               *ChatServiceMock
        defaultExpectation *ChatServiceMockDeleteChatExpectation
        expectations       []*ChatServiceMockDeleteChatExpectation

        callArgs []*ChatServiceMockDeleteChatParams
        mutex    sync.RWMutex

        expectedInvocations uint64
}

// ChatServiceMockDeleteChatExpectation specifies expectation struct of the ChatService.DeleteChat
type ChatServiceMockDeleteChatExpectation struct {
        mock      *ChatServiceMock
        params    *ChatServiceMockDeleteChatParams
        paramPtrs *ChatServiceMockDeleteChatParamPtrs
        results   *ChatServiceMockDeleteChatResults
        Counter   uint64
}

// ChatServiceMockDeleteChatParams contains parameters of the ChatService.DeleteChat
type ChatServiceMockDeleteChatParams struct {
        ctx context.Context
        id  int64
}

// ChatServiceMockDeleteChatParamPtrs contains pointers to parameters of the ChatService.DeleteChat
type ChatServiceMockDeleteChatParamPtrs struct {
        ctx *context.Context
        id  *int64
}

// ChatServiceMockDeleteChatResults contains results of the ChatService.DeleteChat
type ChatServiceMockDeleteChatResults struct {
        err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteChat *mChatServiceMockDeleteChat) Optional() *mChatServiceMockDeleteChat <span class="cov0" title="0">{
        mmDeleteChat.optional = true
        return mmDeleteChat
}</span>

// Expect sets up expected params for ChatService.DeleteChat
func (mmDeleteChat *mChatServiceMockDeleteChat) Expect(ctx context.Context, id int64) *mChatServiceMockDeleteChat <span class="cov8" title="1">{
        if mmDeleteChat.mock.funcDeleteChat != nil </span><span class="cov0" title="0">{
                mmDeleteChat.mock.t.Fatalf("ChatServiceMock.DeleteChat mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmDeleteChat.defaultExpectation == nil </span><span class="cov8" title="1">{
                mmDeleteChat.defaultExpectation = &amp;ChatServiceMockDeleteChatExpectation{}
        }</span>

        <span class="cov8" title="1">if mmDeleteChat.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmDeleteChat.mock.t.Fatalf("ChatServiceMock.DeleteChat mock is already set by ExpectParams functions")
        }</span>

        <span class="cov8" title="1">mmDeleteChat.defaultExpectation.params = &amp;ChatServiceMockDeleteChatParams{ctx, id}
        for _, e := range mmDeleteChat.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmDeleteChat.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmDeleteChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteChat.defaultExpectation.params)
                }</span>
        }

        <span class="cov8" title="1">return mmDeleteChat</span>
}

// ExpectCtxParam1 sets up expected param ctx for ChatService.DeleteChat
func (mmDeleteChat *mChatServiceMockDeleteChat) ExpectCtxParam1(ctx context.Context) *mChatServiceMockDeleteChat <span class="cov0" title="0">{
        if mmDeleteChat.mock.funcDeleteChat != nil </span><span class="cov0" title="0">{
                mmDeleteChat.mock.t.Fatalf("ChatServiceMock.DeleteChat mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmDeleteChat.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDeleteChat.defaultExpectation = &amp;ChatServiceMockDeleteChatExpectation{}
        }</span>

        <span class="cov0" title="0">if mmDeleteChat.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmDeleteChat.mock.t.Fatalf("ChatServiceMock.DeleteChat mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmDeleteChat.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmDeleteChat.defaultExpectation.paramPtrs = &amp;ChatServiceMockDeleteChatParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmDeleteChat.defaultExpectation.paramPtrs.ctx = &amp;ctx

        return mmDeleteChat</span>
}

// ExpectIdParam2 sets up expected param id for ChatService.DeleteChat
func (mmDeleteChat *mChatServiceMockDeleteChat) ExpectIdParam2(id int64) *mChatServiceMockDeleteChat <span class="cov0" title="0">{
        if mmDeleteChat.mock.funcDeleteChat != nil </span><span class="cov0" title="0">{
                mmDeleteChat.mock.t.Fatalf("ChatServiceMock.DeleteChat mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmDeleteChat.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDeleteChat.defaultExpectation = &amp;ChatServiceMockDeleteChatExpectation{}
        }</span>

        <span class="cov0" title="0">if mmDeleteChat.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmDeleteChat.mock.t.Fatalf("ChatServiceMock.DeleteChat mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmDeleteChat.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmDeleteChat.defaultExpectation.paramPtrs = &amp;ChatServiceMockDeleteChatParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmDeleteChat.defaultExpectation.paramPtrs.id = &amp;id

        return mmDeleteChat</span>
}

// Inspect accepts an inspector function that has same arguments as the ChatService.DeleteChat
func (mmDeleteChat *mChatServiceMockDeleteChat) Inspect(f func(ctx context.Context, id int64)) *mChatServiceMockDeleteChat <span class="cov0" title="0">{
        if mmDeleteChat.mock.inspectFuncDeleteChat != nil </span><span class="cov0" title="0">{
                mmDeleteChat.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.DeleteChat")
        }</span>

        <span class="cov0" title="0">mmDeleteChat.mock.inspectFuncDeleteChat = f

        return mmDeleteChat</span>
}

// Return sets up results that will be returned by ChatService.DeleteChat
func (mmDeleteChat *mChatServiceMockDeleteChat) Return(err error) *ChatServiceMock <span class="cov8" title="1">{
        if mmDeleteChat.mock.funcDeleteChat != nil </span><span class="cov0" title="0">{
                mmDeleteChat.mock.t.Fatalf("ChatServiceMock.DeleteChat mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmDeleteChat.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDeleteChat.defaultExpectation = &amp;ChatServiceMockDeleteChatExpectation{mock: mmDeleteChat.mock}
        }</span>
        <span class="cov8" title="1">mmDeleteChat.defaultExpectation.results = &amp;ChatServiceMockDeleteChatResults{err}
        return mmDeleteChat.mock</span>
}

// Set uses given function f to mock the ChatService.DeleteChat method
func (mmDeleteChat *mChatServiceMockDeleteChat) Set(f func(ctx context.Context, id int64) (err error)) *ChatServiceMock <span class="cov0" title="0">{
        if mmDeleteChat.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmDeleteChat.mock.t.Fatalf("Default expectation is already set for the ChatService.DeleteChat method")
        }</span>

        <span class="cov0" title="0">if len(mmDeleteChat.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmDeleteChat.mock.t.Fatalf("Some expectations are already set for the ChatService.DeleteChat method")
        }</span>

        <span class="cov0" title="0">mmDeleteChat.mock.funcDeleteChat = f
        return mmDeleteChat.mock</span>
}

// When sets expectation for the ChatService.DeleteChat which will trigger the result defined by the following
// Then helper
func (mmDeleteChat *mChatServiceMockDeleteChat) When(ctx context.Context, id int64) *ChatServiceMockDeleteChatExpectation <span class="cov0" title="0">{
        if mmDeleteChat.mock.funcDeleteChat != nil </span><span class="cov0" title="0">{
                mmDeleteChat.mock.t.Fatalf("ChatServiceMock.DeleteChat mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;ChatServiceMockDeleteChatExpectation{
                mock:   mmDeleteChat.mock,
                params: &amp;ChatServiceMockDeleteChatParams{ctx, id},
        }
        mmDeleteChat.expectations = append(mmDeleteChat.expectations, expectation)
        return expectation</span>
}

// Then sets up ChatService.DeleteChat return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockDeleteChatExpectation) Then(err error) *ChatServiceMock <span class="cov0" title="0">{
        e.results = &amp;ChatServiceMockDeleteChatResults{err}
        return e.mock
}</span>

// Times sets number of times ChatService.DeleteChat should be invoked
func (mmDeleteChat *mChatServiceMockDeleteChat) Times(n uint64) *mChatServiceMockDeleteChat <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmDeleteChat.mock.t.Fatalf("Times of ChatServiceMock.DeleteChat mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmDeleteChat.expectedInvocations, n)
        return mmDeleteChat</span>
}

func (mmDeleteChat *mChatServiceMockDeleteChat) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmDeleteChat.expectations) == 0 &amp;&amp; mmDeleteChat.defaultExpectation == nil &amp;&amp; mmDeleteChat.mock.funcDeleteChat == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">totalInvocations := mm_atomic.LoadUint64(&amp;mmDeleteChat.mock.afterDeleteChatCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmDeleteChat.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// DeleteChat implements service.ChatService
func (mmDeleteChat *ChatServiceMock) DeleteChat(ctx context.Context, id int64) (err error) <span class="cov8" title="1">{
        mm_atomic.AddUint64(&amp;mmDeleteChat.beforeDeleteChatCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmDeleteChat.afterDeleteChatCounter, 1)

        if mmDeleteChat.inspectFuncDeleteChat != nil </span><span class="cov0" title="0">{
                mmDeleteChat.inspectFuncDeleteChat(ctx, id)
        }</span>

        <span class="cov8" title="1">mm_params := ChatServiceMockDeleteChatParams{ctx, id}

        // Record call args
        mmDeleteChat.DeleteChatMock.mutex.Lock()
        mmDeleteChat.DeleteChatMock.callArgs = append(mmDeleteChat.DeleteChatMock.callArgs, &amp;mm_params)
        mmDeleteChat.DeleteChatMock.mutex.Unlock()

        for _, e := range mmDeleteChat.DeleteChatMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov8" title="1">if mmDeleteChat.DeleteChatMock.defaultExpectation != nil </span><span class="cov8" title="1">{
                mm_atomic.AddUint64(&amp;mmDeleteChat.DeleteChatMock.defaultExpectation.Counter, 1)
                mm_want := mmDeleteChat.DeleteChatMock.defaultExpectation.params
                mm_want_ptrs := mmDeleteChat.DeleteChatMock.defaultExpectation.paramPtrs

                mm_got := ChatServiceMockDeleteChatParams{ctx, id}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmDeleteChat.t.Errorf("ChatServiceMock.DeleteChat got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.id != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.id, mm_got.id) </span><span class="cov0" title="0">{
                                mmDeleteChat.t.Errorf("ChatServiceMock.DeleteChat got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
                        }</span>

                } else<span class="cov8" title="1"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmDeleteChat.t.Errorf("ChatServiceMock.DeleteChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov8" title="1">mm_results := mmDeleteChat.DeleteChatMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmDeleteChat.t.Fatal("No results are set for the ChatServiceMock.DeleteChat")
                }</span>
                <span class="cov8" title="1">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmDeleteChat.funcDeleteChat != nil </span><span class="cov0" title="0">{
                return mmDeleteChat.funcDeleteChat(ctx, id)
        }</span>
        <span class="cov0" title="0">mmDeleteChat.t.Fatalf("Unexpected call to ChatServiceMock.DeleteChat. %v %v", ctx, id)
        return</span>
}

// DeleteChatAfterCounter returns a count of finished ChatServiceMock.DeleteChat invocations
func (mmDeleteChat *ChatServiceMock) DeleteChatAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmDeleteChat.afterDeleteChatCounter)
}</span>

// DeleteChatBeforeCounter returns a count of ChatServiceMock.DeleteChat invocations
func (mmDeleteChat *ChatServiceMock) DeleteChatBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmDeleteChat.beforeDeleteChatCounter)
}</span>

// Calls returns a list of arguments used in each call to ChatServiceMock.DeleteChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteChat *mChatServiceMockDeleteChat) Calls() []*ChatServiceMockDeleteChatParams <span class="cov0" title="0">{
        mmDeleteChat.mutex.RLock()

        argCopy := make([]*ChatServiceMockDeleteChatParams, len(mmDeleteChat.callArgs))
        copy(argCopy, mmDeleteChat.callArgs)

        mmDeleteChat.mutex.RUnlock()

        return argCopy
}</span>

// MinimockDeleteChatDone returns true if the count of the DeleteChat invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockDeleteChatDone() bool <span class="cov8" title="1">{
        if m.DeleteChatMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.DeleteChatMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.DeleteChatMock.invocationsDone()</span>
}

// MinimockDeleteChatInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockDeleteChatInspect() <span class="cov0" title="0">{
        for _, e := range m.DeleteChatMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to ChatServiceMock.DeleteChat with params: %#v", *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterDeleteChatCounter := mm_atomic.LoadUint64(&amp;m.afterDeleteChatCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.DeleteChatMock.defaultExpectation != nil &amp;&amp; afterDeleteChatCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.DeleteChatMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to ChatServiceMock.DeleteChat")
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to ChatServiceMock.DeleteChat with params: %#v", *m.DeleteChatMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcDeleteChat != nil &amp;&amp; afterDeleteChatCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Error("Expected call to ChatServiceMock.DeleteChat")
        }</span>

        <span class="cov0" title="0">if !m.DeleteChatMock.invocationsDone() &amp;&amp; afterDeleteChatCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to ChatServiceMock.DeleteChat but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.DeleteChatMock.expectedInvocations), afterDeleteChatCounter)
        }</span>
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ChatServiceMock) MinimockFinish() <span class="cov8" title="1">{
        m.finishOnce.Do(func() </span><span class="cov8" title="1">{
                if !m.minimockDone() </span><span class="cov0" title="0">{
                        m.MinimockCreateChatInspect()

                        m.MinimockDeleteChatInspect()
                }</span>
        })
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ChatServiceMock) MinimockWait(timeout mm_time.Duration) <span class="cov0" title="0">{
        timeoutCh := mm_time.After(timeout)
        for </span><span class="cov0" title="0">{
                if m.minimockDone() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-timeoutCh:<span class="cov0" title="0">
                        m.MinimockFinish()
                        return</span>
                case &lt;-mm_time.After(10 * mm_time.Millisecond):<span class="cov0" title="0"></span>
                }
        }
}

func (m *ChatServiceMock) minimockDone() bool <span class="cov8" title="1">{
        done := true
        return done &amp;&amp;
                m.MinimockCreateChatDone() &amp;&amp;
                m.MinimockDeleteChatDone()
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">// Code generated by http://github.com/gojuno/minimock (v3.3.14). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/ArtEmerged/o_chat-server/internal/service.MessageService -o message_service_minimock.go -n MessageServiceMock -p mocks

import (
        "context"
        "sync"
        mm_atomic "sync/atomic"
        mm_time "time"

        "github.com/ArtEmerged/o_chat-server/internal/model"
        "github.com/gojuno/minimock/v3"
)

// MessageServiceMock implements service.MessageService
type MessageServiceMock struct {
        t          minimock.Tester
        finishOnce sync.Once

        funcSendMessage          func(ctx context.Context, in *model.SendMessageRequest) (err error)
        inspectFuncSendMessage   func(ctx context.Context, in *model.SendMessageRequest)
        afterSendMessageCounter  uint64
        beforeSendMessageCounter uint64
        SendMessageMock          mMessageServiceMockSendMessage
}

// NewMessageServiceMock returns a mock for service.MessageService
func NewMessageServiceMock(t minimock.Tester) *MessageServiceMock <span class="cov8" title="1">{
        m := &amp;MessageServiceMock{t: t}

        if controller, ok := t.(minimock.MockController); ok </span><span class="cov8" title="1">{
                controller.RegisterMocker(m)
        }</span>

        <span class="cov8" title="1">m.SendMessageMock = mMessageServiceMockSendMessage{mock: m}
        m.SendMessageMock.callArgs = []*MessageServiceMockSendMessageParams{}

        t.Cleanup(m.MinimockFinish)

        return m</span>
}

type mMessageServiceMockSendMessage struct {
        optional           bool
        mock               *MessageServiceMock
        defaultExpectation *MessageServiceMockSendMessageExpectation
        expectations       []*MessageServiceMockSendMessageExpectation

        callArgs []*MessageServiceMockSendMessageParams
        mutex    sync.RWMutex

        expectedInvocations uint64
}

// MessageServiceMockSendMessageExpectation specifies expectation struct of the MessageService.SendMessage
type MessageServiceMockSendMessageExpectation struct {
        mock      *MessageServiceMock
        params    *MessageServiceMockSendMessageParams
        paramPtrs *MessageServiceMockSendMessageParamPtrs
        results   *MessageServiceMockSendMessageResults
        Counter   uint64
}

// MessageServiceMockSendMessageParams contains parameters of the MessageService.SendMessage
type MessageServiceMockSendMessageParams struct {
        ctx context.Context
        in  *model.SendMessageRequest
}

// MessageServiceMockSendMessageParamPtrs contains pointers to parameters of the MessageService.SendMessage
type MessageServiceMockSendMessageParamPtrs struct {
        ctx *context.Context
        in  **model.SendMessageRequest
}

// MessageServiceMockSendMessageResults contains results of the MessageService.SendMessage
type MessageServiceMockSendMessageResults struct {
        err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSendMessage *mMessageServiceMockSendMessage) Optional() *mMessageServiceMockSendMessage <span class="cov0" title="0">{
        mmSendMessage.optional = true
        return mmSendMessage
}</span>

// Expect sets up expected params for MessageService.SendMessage
func (mmSendMessage *mMessageServiceMockSendMessage) Expect(ctx context.Context, in *model.SendMessageRequest) *mMessageServiceMockSendMessage <span class="cov8" title="1">{
        if mmSendMessage.mock.funcSendMessage != nil </span><span class="cov0" title="0">{
                mmSendMessage.mock.t.Fatalf("MessageServiceMock.SendMessage mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmSendMessage.defaultExpectation == nil </span><span class="cov8" title="1">{
                mmSendMessage.defaultExpectation = &amp;MessageServiceMockSendMessageExpectation{}
        }</span>

        <span class="cov8" title="1">if mmSendMessage.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmSendMessage.mock.t.Fatalf("MessageServiceMock.SendMessage mock is already set by ExpectParams functions")
        }</span>

        <span class="cov8" title="1">mmSendMessage.defaultExpectation.params = &amp;MessageServiceMockSendMessageParams{ctx, in}
        for _, e := range mmSendMessage.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmSendMessage.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmSendMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendMessage.defaultExpectation.params)
                }</span>
        }

        <span class="cov8" title="1">return mmSendMessage</span>
}

// ExpectCtxParam1 sets up expected param ctx for MessageService.SendMessage
func (mmSendMessage *mMessageServiceMockSendMessage) ExpectCtxParam1(ctx context.Context) *mMessageServiceMockSendMessage <span class="cov0" title="0">{
        if mmSendMessage.mock.funcSendMessage != nil </span><span class="cov0" title="0">{
                mmSendMessage.mock.t.Fatalf("MessageServiceMock.SendMessage mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmSendMessage.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmSendMessage.defaultExpectation = &amp;MessageServiceMockSendMessageExpectation{}
        }</span>

        <span class="cov0" title="0">if mmSendMessage.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmSendMessage.mock.t.Fatalf("MessageServiceMock.SendMessage mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmSendMessage.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmSendMessage.defaultExpectation.paramPtrs = &amp;MessageServiceMockSendMessageParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmSendMessage.defaultExpectation.paramPtrs.ctx = &amp;ctx

        return mmSendMessage</span>
}

// ExpectInParam2 sets up expected param in for MessageService.SendMessage
func (mmSendMessage *mMessageServiceMockSendMessage) ExpectInParam2(in *model.SendMessageRequest) *mMessageServiceMockSendMessage <span class="cov0" title="0">{
        if mmSendMessage.mock.funcSendMessage != nil </span><span class="cov0" title="0">{
                mmSendMessage.mock.t.Fatalf("MessageServiceMock.SendMessage mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmSendMessage.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmSendMessage.defaultExpectation = &amp;MessageServiceMockSendMessageExpectation{}
        }</span>

        <span class="cov0" title="0">if mmSendMessage.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmSendMessage.mock.t.Fatalf("MessageServiceMock.SendMessage mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmSendMessage.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmSendMessage.defaultExpectation.paramPtrs = &amp;MessageServiceMockSendMessageParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmSendMessage.defaultExpectation.paramPtrs.in = &amp;in

        return mmSendMessage</span>
}

// Inspect accepts an inspector function that has same arguments as the MessageService.SendMessage
func (mmSendMessage *mMessageServiceMockSendMessage) Inspect(f func(ctx context.Context, in *model.SendMessageRequest)) *mMessageServiceMockSendMessage <span class="cov0" title="0">{
        if mmSendMessage.mock.inspectFuncSendMessage != nil </span><span class="cov0" title="0">{
                mmSendMessage.mock.t.Fatalf("Inspect function is already set for MessageServiceMock.SendMessage")
        }</span>

        <span class="cov0" title="0">mmSendMessage.mock.inspectFuncSendMessage = f

        return mmSendMessage</span>
}

// Return sets up results that will be returned by MessageService.SendMessage
func (mmSendMessage *mMessageServiceMockSendMessage) Return(err error) *MessageServiceMock <span class="cov8" title="1">{
        if mmSendMessage.mock.funcSendMessage != nil </span><span class="cov0" title="0">{
                mmSendMessage.mock.t.Fatalf("MessageServiceMock.SendMessage mock is already set by Set")
        }</span>

        <span class="cov8" title="1">if mmSendMessage.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmSendMessage.defaultExpectation = &amp;MessageServiceMockSendMessageExpectation{mock: mmSendMessage.mock}
        }</span>
        <span class="cov8" title="1">mmSendMessage.defaultExpectation.results = &amp;MessageServiceMockSendMessageResults{err}
        return mmSendMessage.mock</span>
}

// Set uses given function f to mock the MessageService.SendMessage method
func (mmSendMessage *mMessageServiceMockSendMessage) Set(f func(ctx context.Context, in *model.SendMessageRequest) (err error)) *MessageServiceMock <span class="cov0" title="0">{
        if mmSendMessage.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmSendMessage.mock.t.Fatalf("Default expectation is already set for the MessageService.SendMessage method")
        }</span>

        <span class="cov0" title="0">if len(mmSendMessage.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmSendMessage.mock.t.Fatalf("Some expectations are already set for the MessageService.SendMessage method")
        }</span>

        <span class="cov0" title="0">mmSendMessage.mock.funcSendMessage = f
        return mmSendMessage.mock</span>
}

// When sets expectation for the MessageService.SendMessage which will trigger the result defined by the following
// Then helper
func (mmSendMessage *mMessageServiceMockSendMessage) When(ctx context.Context, in *model.SendMessageRequest) *MessageServiceMockSendMessageExpectation <span class="cov0" title="0">{
        if mmSendMessage.mock.funcSendMessage != nil </span><span class="cov0" title="0">{
                mmSendMessage.mock.t.Fatalf("MessageServiceMock.SendMessage mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;MessageServiceMockSendMessageExpectation{
                mock:   mmSendMessage.mock,
                params: &amp;MessageServiceMockSendMessageParams{ctx, in},
        }
        mmSendMessage.expectations = append(mmSendMessage.expectations, expectation)
        return expectation</span>
}

// Then sets up MessageService.SendMessage return parameters for the expectation previously defined by the When method
func (e *MessageServiceMockSendMessageExpectation) Then(err error) *MessageServiceMock <span class="cov0" title="0">{
        e.results = &amp;MessageServiceMockSendMessageResults{err}
        return e.mock
}</span>

// Times sets number of times MessageService.SendMessage should be invoked
func (mmSendMessage *mMessageServiceMockSendMessage) Times(n uint64) *mMessageServiceMockSendMessage <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmSendMessage.mock.t.Fatalf("Times of MessageServiceMock.SendMessage mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmSendMessage.expectedInvocations, n)
        return mmSendMessage</span>
}

func (mmSendMessage *mMessageServiceMockSendMessage) invocationsDone() bool <span class="cov8" title="1">{
        if len(mmSendMessage.expectations) == 0 &amp;&amp; mmSendMessage.defaultExpectation == nil &amp;&amp; mmSendMessage.mock.funcSendMessage == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">totalInvocations := mm_atomic.LoadUint64(&amp;mmSendMessage.mock.afterSendMessageCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmSendMessage.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// SendMessage implements service.MessageService
func (mmSendMessage *MessageServiceMock) SendMessage(ctx context.Context, in *model.SendMessageRequest) (err error) <span class="cov8" title="1">{
        mm_atomic.AddUint64(&amp;mmSendMessage.beforeSendMessageCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmSendMessage.afterSendMessageCounter, 1)

        if mmSendMessage.inspectFuncSendMessage != nil </span><span class="cov0" title="0">{
                mmSendMessage.inspectFuncSendMessage(ctx, in)
        }</span>

        <span class="cov8" title="1">mm_params := MessageServiceMockSendMessageParams{ctx, in}

        // Record call args
        mmSendMessage.SendMessageMock.mutex.Lock()
        mmSendMessage.SendMessageMock.callArgs = append(mmSendMessage.SendMessageMock.callArgs, &amp;mm_params)
        mmSendMessage.SendMessageMock.mutex.Unlock()

        for _, e := range mmSendMessage.SendMessageMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov8" title="1">if mmSendMessage.SendMessageMock.defaultExpectation != nil </span><span class="cov8" title="1">{
                mm_atomic.AddUint64(&amp;mmSendMessage.SendMessageMock.defaultExpectation.Counter, 1)
                mm_want := mmSendMessage.SendMessageMock.defaultExpectation.params
                mm_want_ptrs := mmSendMessage.SendMessageMock.defaultExpectation.paramPtrs

                mm_got := MessageServiceMockSendMessageParams{ctx, in}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmSendMessage.t.Errorf("MessageServiceMock.SendMessage got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.in != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.in, mm_got.in) </span><span class="cov0" title="0">{
                                mmSendMessage.t.Errorf("MessageServiceMock.SendMessage got unexpected parameter in, want: %#v, got: %#v%s\n", *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
                        }</span>

                } else<span class="cov8" title="1"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmSendMessage.t.Errorf("MessageServiceMock.SendMessage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov8" title="1">mm_results := mmSendMessage.SendMessageMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmSendMessage.t.Fatal("No results are set for the MessageServiceMock.SendMessage")
                }</span>
                <span class="cov8" title="1">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmSendMessage.funcSendMessage != nil </span><span class="cov0" title="0">{
                return mmSendMessage.funcSendMessage(ctx, in)
        }</span>
        <span class="cov0" title="0">mmSendMessage.t.Fatalf("Unexpected call to MessageServiceMock.SendMessage. %v %v", ctx, in)
        return</span>
}

// SendMessageAfterCounter returns a count of finished MessageServiceMock.SendMessage invocations
func (mmSendMessage *MessageServiceMock) SendMessageAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmSendMessage.afterSendMessageCounter)
}</span>

// SendMessageBeforeCounter returns a count of MessageServiceMock.SendMessage invocations
func (mmSendMessage *MessageServiceMock) SendMessageBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmSendMessage.beforeSendMessageCounter)
}</span>

// Calls returns a list of arguments used in each call to MessageServiceMock.SendMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendMessage *mMessageServiceMockSendMessage) Calls() []*MessageServiceMockSendMessageParams <span class="cov0" title="0">{
        mmSendMessage.mutex.RLock()

        argCopy := make([]*MessageServiceMockSendMessageParams, len(mmSendMessage.callArgs))
        copy(argCopy, mmSendMessage.callArgs)

        mmSendMessage.mutex.RUnlock()

        return argCopy
}</span>

// MinimockSendMessageDone returns true if the count of the SendMessage invocations corresponds
// the number of defined expectations
func (m *MessageServiceMock) MinimockSendMessageDone() bool <span class="cov8" title="1">{
        if m.SendMessageMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range m.SendMessageMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return m.SendMessageMock.invocationsDone()</span>
}

// MinimockSendMessageInspect logs each unmet expectation
func (m *MessageServiceMock) MinimockSendMessageInspect() <span class="cov0" title="0">{
        for _, e := range m.SendMessageMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to MessageServiceMock.SendMessage with params: %#v", *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterSendMessageCounter := mm_atomic.LoadUint64(&amp;m.afterSendMessageCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.SendMessageMock.defaultExpectation != nil &amp;&amp; afterSendMessageCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.SendMessageMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Error("Expected call to MessageServiceMock.SendMessage")
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to MessageServiceMock.SendMessage with params: %#v", *m.SendMessageMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcSendMessage != nil &amp;&amp; afterSendMessageCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Error("Expected call to MessageServiceMock.SendMessage")
        }</span>

        <span class="cov0" title="0">if !m.SendMessageMock.invocationsDone() &amp;&amp; afterSendMessageCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to MessageServiceMock.SendMessage but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.SendMessageMock.expectedInvocations), afterSendMessageCounter)
        }</span>
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *MessageServiceMock) MinimockFinish() <span class="cov8" title="1">{
        m.finishOnce.Do(func() </span><span class="cov8" title="1">{
                if !m.minimockDone() </span><span class="cov0" title="0">{
                        m.MinimockSendMessageInspect()
                }</span>
        })
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *MessageServiceMock) MinimockWait(timeout mm_time.Duration) <span class="cov0" title="0">{
        timeoutCh := mm_time.After(timeout)
        for </span><span class="cov0" title="0">{
                if m.minimockDone() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-timeoutCh:<span class="cov0" title="0">
                        m.MinimockFinish()
                        return</span>
                case &lt;-mm_time.After(10 * mm_time.Millisecond):<span class="cov0" title="0"></span>
                }
        }
}

func (m *MessageServiceMock) minimockDone() bool <span class="cov8" title="1">{
        done := true
        return done &amp;&amp;
                m.MinimockSendMessageDone()
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.34.2
//         protoc        v4.24.3
// source: chat.proto

package chat_v1

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        emptypb "google.golang.org/protobuf/types/known/emptypb"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type CreateChatRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        ChatName  string  `protobuf:"bytes,1,opt,name=chat_name,json=chatName,proto3" json:"chat_name,omitempty"`
        CreatorId int64   `protobuf:"varint,2,opt,name=creator_id,json=creatorId,proto3" json:"creator_id,omitempty"`
        UserIds   []int64 `protobuf:"varint,3,rep,packed,name=user_ids,json=userIds,proto3" json:"user_ids,omitempty"`
}

func (x *CreateChatRequest) Reset() <span class="cov0" title="0">{
        *x = CreateChatRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_chat_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *CreateChatRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateChatRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateChatRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_chat_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateChatRequest.ProtoReflect.Descriptor instead.
func (*CreateChatRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_chat_proto_rawDescGZIP(), []int{0}
}</span>

func (x *CreateChatRequest) GetChatName() string <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.ChatName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateChatRequest) GetCreatorId() int64 <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.CreatorId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *CreateChatRequest) GetUserIds() []int64 <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.UserIds
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CreateChatResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (x *CreateChatResponse) Reset() <span class="cov0" title="0">{
        *x = CreateChatResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_chat_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *CreateChatResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateChatResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateChatResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_chat_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateChatResponse.ProtoReflect.Descriptor instead.
func (*CreateChatResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_chat_proto_rawDescGZIP(), []int{1}
}</span>

func (x *CreateChatResponse) GetId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type DeleteChatRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (x *DeleteChatRequest) Reset() <span class="cov0" title="0">{
        *x = DeleteChatRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_chat_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DeleteChatRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteChatRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteChatRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_chat_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteChatRequest.ProtoReflect.Descriptor instead.
func (*DeleteChatRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_chat_proto_rawDescGZIP(), []int{2}
}</span>

func (x *DeleteChatRequest) GetId() int64 <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type SendMessageRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        ChatId     int64  `protobuf:"varint,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
        FromUserId int64  `protobuf:"varint,2,opt,name=from_user_id,json=fromUserId,proto3" json:"from_user_id,omitempty"`
        Text       string `protobuf:"bytes,3,opt,name=text,proto3" json:"text,omitempty"`
}

func (x *SendMessageRequest) Reset() <span class="cov0" title="0">{
        *x = SendMessageRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_chat_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *SendMessageRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SendMessageRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SendMessageRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_chat_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SendMessageRequest.ProtoReflect.Descriptor instead.
func (*SendMessageRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_chat_proto_rawDescGZIP(), []int{3}
}</span>

func (x *SendMessageRequest) GetChatId() int64 <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.ChatId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SendMessageRequest) GetFromUserId() int64 <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.FromUserId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SendMessageRequest) GetText() string <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.Text
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type SendMessageResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *SendMessageResponse) Reset() <span class="cov0" title="0">{
        *x = SendMessageResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_chat_proto_msgTypes[4]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *SendMessageResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SendMessageResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SendMessageResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_chat_proto_msgTypes[4]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SendMessageResponse.ProtoReflect.Descriptor instead.
func (*SendMessageResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_chat_proto_rawDescGZIP(), []int{4}
}</span>

var File_chat_proto protoreflect.FileDescriptor

var file_chat_proto_rawDesc = []byte{
        0x0a, 0x0a, 0x63, 0x68, 0x61, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x07, 0x63, 0x68,
        0x61, 0x74, 0x5f, 0x76, 0x31, 0x1a, 0x1b, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x22, 0x6a, 0x0a, 0x11, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x43, 0x68, 0x61, 0x74,
        0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x63, 0x68, 0x61, 0x74, 0x5f,
        0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x63, 0x68, 0x61, 0x74,
        0x4e, 0x61, 0x6d, 0x65, 0x12, 0x1d, 0x0a, 0x0a, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x5f,
        0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52, 0x09, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f,
        0x72, 0x49, 0x64, 0x12, 0x19, 0x0a, 0x08, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x73, 0x18,
        0x03, 0x20, 0x03, 0x28, 0x03, 0x52, 0x07, 0x75, 0x73, 0x65, 0x72, 0x49, 0x64, 0x73, 0x22, 0x24,
        0x0a, 0x12, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x43, 0x68, 0x61, 0x74, 0x52, 0x65, 0x73, 0x70,
        0x6f, 0x6e, 0x73, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03,
        0x52, 0x02, 0x69, 0x64, 0x22, 0x23, 0x0a, 0x11, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x43, 0x68,
        0x61, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x02, 0x69, 0x64, 0x22, 0x63, 0x0a, 0x12, 0x53, 0x65, 0x6e,
        0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12,
        0x17, 0x0a, 0x07, 0x63, 0x68, 0x61, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03,
        0x52, 0x06, 0x63, 0x68, 0x61, 0x74, 0x49, 0x64, 0x12, 0x20, 0x0a, 0x0c, 0x66, 0x72, 0x6f, 0x6d,
        0x5f, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0a,
        0x66, 0x72, 0x6f, 0x6d, 0x55, 0x73, 0x65, 0x72, 0x49, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x74, 0x65,
        0x78, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x74, 0x65, 0x78, 0x74, 0x22, 0x15,
        0x0a, 0x13, 0x53, 0x65, 0x6e, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x52, 0x65, 0x73,
        0x70, 0x6f, 0x6e, 0x73, 0x65, 0x32, 0xdb, 0x01, 0x0a, 0x06, 0x43, 0x68, 0x61, 0x74, 0x56, 0x31,
        0x12, 0x45, 0x0a, 0x0a, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x43, 0x68, 0x61, 0x74, 0x12, 0x1a,
        0x2e, 0x63, 0x68, 0x61, 0x74, 0x5f, 0x76, 0x31, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x43,
        0x68, 0x61, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1b, 0x2e, 0x63, 0x68, 0x61,
        0x74, 0x5f, 0x76, 0x31, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x43, 0x68, 0x61, 0x74, 0x52,
        0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x40, 0x0a, 0x0a, 0x44, 0x65, 0x6c, 0x65, 0x74,
        0x65, 0x43, 0x68, 0x61, 0x74, 0x12, 0x1a, 0x2e, 0x63, 0x68, 0x61, 0x74, 0x5f, 0x76, 0x31, 0x2e,
        0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x43, 0x68, 0x61, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
        0x74, 0x1a, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x62, 0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x12, 0x48, 0x0a, 0x0b, 0x53, 0x65, 0x6e,
        0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x1b, 0x2e, 0x63, 0x68, 0x61, 0x74, 0x5f,
        0x76, 0x31, 0x2e, 0x53, 0x65, 0x6e, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1c, 0x2e, 0x63, 0x68, 0x61, 0x74, 0x5f, 0x76, 0x31, 0x2e,
        0x53, 0x65, 0x6e, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f,
        0x6e, 0x73, 0x65, 0x42, 0x39, 0x5a, 0x37, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f,
        0x6d, 0x2f, 0x41, 0x72, 0x74, 0x45, 0x6d, 0x65, 0x72, 0x67, 0x65, 0x64, 0x2f, 0x6f, 0x5f, 0x63,
        0x68, 0x61, 0x74, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x2f, 0x70, 0x6b, 0x67, 0x2f, 0x63,
        0x68, 0x61, 0x74, 0x5f, 0x76, 0x31, 0x3b, 0x63, 0x68, 0x61, 0x74, 0x5f, 0x76, 0x31, 0x62, 0x06,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_chat_proto_rawDescOnce sync.Once
        file_chat_proto_rawDescData = file_chat_proto_rawDesc
)

func file_chat_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_chat_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_chat_proto_rawDescData = protoimpl.X.CompressGZIP(file_chat_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_chat_proto_rawDescData</span>
}

var file_chat_proto_msgTypes = make([]protoimpl.MessageInfo, 5)
var file_chat_proto_goTypes = []any{
        (*CreateChatRequest)(nil),   // 0: chat_v1.CreateChatRequest
        (*CreateChatResponse)(nil),  // 1: chat_v1.CreateChatResponse
        (*DeleteChatRequest)(nil),   // 2: chat_v1.DeleteChatRequest
        (*SendMessageRequest)(nil),  // 3: chat_v1.SendMessageRequest
        (*SendMessageResponse)(nil), // 4: chat_v1.SendMessageResponse
        (*emptypb.Empty)(nil),       // 5: google.protobuf.Empty
}
var file_chat_proto_depIdxs = []int32{
        0, // 0: chat_v1.ChatV1.CreateChat:input_type -&gt; chat_v1.CreateChatRequest
        2, // 1: chat_v1.ChatV1.DeleteChat:input_type -&gt; chat_v1.DeleteChatRequest
        3, // 2: chat_v1.ChatV1.SendMessage:input_type -&gt; chat_v1.SendMessageRequest
        1, // 3: chat_v1.ChatV1.CreateChat:output_type -&gt; chat_v1.CreateChatResponse
        5, // 4: chat_v1.ChatV1.DeleteChat:output_type -&gt; google.protobuf.Empty
        4, // 5: chat_v1.ChatV1.SendMessage:output_type -&gt; chat_v1.SendMessageResponse
        3, // [3:6] is the sub-list for method output_type
        0, // [0:3] is the sub-list for method input_type
        0, // [0:0] is the sub-list for extension type_name
        0, // [0:0] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_chat_proto_init() }</span>
func file_chat_proto_init() <span class="cov8" title="1">{
        if File_chat_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_chat_proto_msgTypes[0].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*CreateChatRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_chat_proto_msgTypes[1].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*CreateChatResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_chat_proto_msgTypes[2].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*DeleteChatRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_chat_proto_msgTypes[3].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*SendMessageRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_chat_proto_msgTypes[4].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*SendMessageResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_chat_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   5,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_chat_proto_goTypes,
                DependencyIndexes: file_chat_proto_depIdxs,
                MessageInfos:      file_chat_proto_msgTypes,
        }.Build()
        File_chat_proto = out.File
        file_chat_proto_rawDesc = nil
        file_chat_proto_goTypes = nil
        file_chat_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.4.0
// - protoc             v4.24.3
// source: chat.proto

package chat_v1

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
        emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.62.0 or later.
const _ = grpc.SupportPackageIsVersion8

const (
        ChatV1_CreateChat_FullMethodName  = "/chat_v1.ChatV1/CreateChat"
        ChatV1_DeleteChat_FullMethodName  = "/chat_v1.ChatV1/DeleteChat"
        ChatV1_SendMessage_FullMethodName = "/chat_v1.ChatV1/SendMessage"
)

// ChatV1Client is the client API for ChatV1 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ChatV1Client interface {
        CreateChat(ctx context.Context, in *CreateChatRequest, opts ...grpc.CallOption) (*CreateChatResponse, error)
        DeleteChat(ctx context.Context, in *DeleteChatRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
        SendMessage(ctx context.Context, in *SendMessageRequest, opts ...grpc.CallOption) (*SendMessageResponse, error)
}

type chatV1Client struct {
        cc grpc.ClientConnInterface
}

func NewChatV1Client(cc grpc.ClientConnInterface) ChatV1Client <span class="cov0" title="0">{
        return &amp;chatV1Client{cc}
}</span>

func (c *chatV1Client) CreateChat(ctx context.Context, in *CreateChatRequest, opts ...grpc.CallOption) (*CreateChatResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(CreateChatResponse)
        err := c.cc.Invoke(ctx, ChatV1_CreateChat_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *chatV1Client) DeleteChat(ctx context.Context, in *DeleteChatRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(emptypb.Empty)
        err := c.cc.Invoke(ctx, ChatV1_DeleteChat_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *chatV1Client) SendMessage(ctx context.Context, in *SendMessageRequest, opts ...grpc.CallOption) (*SendMessageResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(SendMessageResponse)
        err := c.cc.Invoke(ctx, ChatV1_SendMessage_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// ChatV1Server is the server API for ChatV1 service.
// All implementations must embed UnimplementedChatV1Server
// for forward compatibility
type ChatV1Server interface {
        CreateChat(context.Context, *CreateChatRequest) (*CreateChatResponse, error)
        DeleteChat(context.Context, *DeleteChatRequest) (*emptypb.Empty, error)
        SendMessage(context.Context, *SendMessageRequest) (*SendMessageResponse, error)
        mustEmbedUnimplementedChatV1Server()
}

// UnimplementedChatV1Server must be embedded to have forward compatible implementations.
type UnimplementedChatV1Server struct {
}

func (UnimplementedChatV1Server) CreateChat(context.Context, *CreateChatRequest) (*CreateChatResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateChat not implemented")
}</span>
func (UnimplementedChatV1Server) DeleteChat(context.Context, *DeleteChatRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteChat not implemented")
}</span>
func (UnimplementedChatV1Server) SendMessage(context.Context, *SendMessageRequest) (*SendMessageResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method SendMessage not implemented")
}</span>
func (UnimplementedChatV1Server) mustEmbedUnimplementedChatV1Server() {<span class="cov0" title="0">}</span>

// UnsafeChatV1Server may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ChatV1Server will
// result in compilation errors.
type UnsafeChatV1Server interface {
        mustEmbedUnimplementedChatV1Server()
}

func RegisterChatV1Server(s grpc.ServiceRegistrar, srv ChatV1Server) <span class="cov0" title="0">{
        s.RegisterService(&amp;ChatV1_ServiceDesc, srv)
}</span>

func _ChatV1_CreateChat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CreateChatRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ChatV1Server).CreateChat(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: ChatV1_CreateChat_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ChatV1Server).CreateChat(ctx, req.(*CreateChatRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ChatV1_DeleteChat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(DeleteChatRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ChatV1Server).DeleteChat(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: ChatV1_DeleteChat_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ChatV1Server).DeleteChat(ctx, req.(*DeleteChatRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ChatV1_SendMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(SendMessageRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ChatV1Server).SendMessage(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: ChatV1_SendMessage_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ChatV1Server).SendMessage(ctx, req.(*SendMessageRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// ChatV1_ServiceDesc is the grpc.ServiceDesc for ChatV1 service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ChatV1_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "chat_v1.ChatV1",
        HandlerType: (*ChatV1Server)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "CreateChat",
                        Handler:    _ChatV1_CreateChat_Handler,
                },
                {
                        MethodName: "DeleteChat",
                        Handler:    _ChatV1_DeleteChat_Handler,
                },
                {
                        MethodName: "SendMessage",
                        Handler:    _ChatV1_SendMessage_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "chat.proto",
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package database

import (
        "context"
        "fmt"
        "time"

        "github.com/jackc/pgx/v4/pgxpool"
)

// NewPostgres creates a new postgres connection.
func NewPostgres(ctx context.Context, dbDNS string) (*pgxpool.Pool, error) <span class="cov0" title="0">{
        conn, err := pgxpool.Connect(ctx, dbDNS)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed connection to postgres db: %w", err)
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, time.Second*5)
        defer cancel()

        if err = conn.Ping(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed ping to postgres db: %w", err)
        }</span>

        <span class="cov0" title="0">return conn, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>

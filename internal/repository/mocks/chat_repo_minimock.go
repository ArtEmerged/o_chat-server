// Code generated by http://github.com/gojuno/minimock (v3.3.14). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/ArtEmerged/o_chat-server/internal/repository.ChatRepo -o chat_repo_minimock.go -n ChatRepoMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/ArtEmerged/o_chat-server/internal/model"
	"github.com/gojuno/minimock/v3"
)

// ChatRepoMock implements repository.ChatRepo
type ChatRepoMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddUsersToChat          func(ctx context.Context, chatID int64, userIDs []int64) (err error)
	inspectFuncAddUsersToChat   func(ctx context.Context, chatID int64, userIDs []int64)
	afterAddUsersToChatCounter  uint64
	beforeAddUsersToChatCounter uint64
	AddUsersToChatMock          mChatRepoMockAddUsersToChat

	funcCreateChat          func(ctx context.Context, in *model.CreateChatRequest) (id int64, err error)
	inspectFuncCreateChat   func(ctx context.Context, in *model.CreateChatRequest)
	afterCreateChatCounter  uint64
	beforeCreateChatCounter uint64
	CreateChatMock          mChatRepoMockCreateChat

	funcDeleteChat          func(ctx context.Context, id int64) (err error)
	inspectFuncDeleteChat   func(ctx context.Context, id int64)
	afterDeleteChatCounter  uint64
	beforeDeleteChatCounter uint64
	DeleteChatMock          mChatRepoMockDeleteChat
}

// NewChatRepoMock returns a mock for repository.ChatRepo
func NewChatRepoMock(t minimock.Tester) *ChatRepoMock {
	m := &ChatRepoMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddUsersToChatMock = mChatRepoMockAddUsersToChat{mock: m}
	m.AddUsersToChatMock.callArgs = []*ChatRepoMockAddUsersToChatParams{}

	m.CreateChatMock = mChatRepoMockCreateChat{mock: m}
	m.CreateChatMock.callArgs = []*ChatRepoMockCreateChatParams{}

	m.DeleteChatMock = mChatRepoMockDeleteChat{mock: m}
	m.DeleteChatMock.callArgs = []*ChatRepoMockDeleteChatParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mChatRepoMockAddUsersToChat struct {
	optional           bool
	mock               *ChatRepoMock
	defaultExpectation *ChatRepoMockAddUsersToChatExpectation
	expectations       []*ChatRepoMockAddUsersToChatExpectation

	callArgs []*ChatRepoMockAddUsersToChatParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ChatRepoMockAddUsersToChatExpectation specifies expectation struct of the ChatRepo.AddUsersToChat
type ChatRepoMockAddUsersToChatExpectation struct {
	mock      *ChatRepoMock
	params    *ChatRepoMockAddUsersToChatParams
	paramPtrs *ChatRepoMockAddUsersToChatParamPtrs
	results   *ChatRepoMockAddUsersToChatResults
	Counter   uint64
}

// ChatRepoMockAddUsersToChatParams contains parameters of the ChatRepo.AddUsersToChat
type ChatRepoMockAddUsersToChatParams struct {
	ctx     context.Context
	chatID  int64
	userIDs []int64
}

// ChatRepoMockAddUsersToChatParamPtrs contains pointers to parameters of the ChatRepo.AddUsersToChat
type ChatRepoMockAddUsersToChatParamPtrs struct {
	ctx     *context.Context
	chatID  *int64
	userIDs *[]int64
}

// ChatRepoMockAddUsersToChatResults contains results of the ChatRepo.AddUsersToChat
type ChatRepoMockAddUsersToChatResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddUsersToChat *mChatRepoMockAddUsersToChat) Optional() *mChatRepoMockAddUsersToChat {
	mmAddUsersToChat.optional = true
	return mmAddUsersToChat
}

// Expect sets up expected params for ChatRepo.AddUsersToChat
func (mmAddUsersToChat *mChatRepoMockAddUsersToChat) Expect(ctx context.Context, chatID int64, userIDs []int64) *mChatRepoMockAddUsersToChat {
	if mmAddUsersToChat.mock.funcAddUsersToChat != nil {
		mmAddUsersToChat.mock.t.Fatalf("ChatRepoMock.AddUsersToChat mock is already set by Set")
	}

	if mmAddUsersToChat.defaultExpectation == nil {
		mmAddUsersToChat.defaultExpectation = &ChatRepoMockAddUsersToChatExpectation{}
	}

	if mmAddUsersToChat.defaultExpectation.paramPtrs != nil {
		mmAddUsersToChat.mock.t.Fatalf("ChatRepoMock.AddUsersToChat mock is already set by ExpectParams functions")
	}

	mmAddUsersToChat.defaultExpectation.params = &ChatRepoMockAddUsersToChatParams{ctx, chatID, userIDs}
	for _, e := range mmAddUsersToChat.expectations {
		if minimock.Equal(e.params, mmAddUsersToChat.defaultExpectation.params) {
			mmAddUsersToChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddUsersToChat.defaultExpectation.params)
		}
	}

	return mmAddUsersToChat
}

// ExpectCtxParam1 sets up expected param ctx for ChatRepo.AddUsersToChat
func (mmAddUsersToChat *mChatRepoMockAddUsersToChat) ExpectCtxParam1(ctx context.Context) *mChatRepoMockAddUsersToChat {
	if mmAddUsersToChat.mock.funcAddUsersToChat != nil {
		mmAddUsersToChat.mock.t.Fatalf("ChatRepoMock.AddUsersToChat mock is already set by Set")
	}

	if mmAddUsersToChat.defaultExpectation == nil {
		mmAddUsersToChat.defaultExpectation = &ChatRepoMockAddUsersToChatExpectation{}
	}

	if mmAddUsersToChat.defaultExpectation.params != nil {
		mmAddUsersToChat.mock.t.Fatalf("ChatRepoMock.AddUsersToChat mock is already set by Expect")
	}

	if mmAddUsersToChat.defaultExpectation.paramPtrs == nil {
		mmAddUsersToChat.defaultExpectation.paramPtrs = &ChatRepoMockAddUsersToChatParamPtrs{}
	}
	mmAddUsersToChat.defaultExpectation.paramPtrs.ctx = &ctx

	return mmAddUsersToChat
}

// ExpectChatIDParam2 sets up expected param chatID for ChatRepo.AddUsersToChat
func (mmAddUsersToChat *mChatRepoMockAddUsersToChat) ExpectChatIDParam2(chatID int64) *mChatRepoMockAddUsersToChat {
	if mmAddUsersToChat.mock.funcAddUsersToChat != nil {
		mmAddUsersToChat.mock.t.Fatalf("ChatRepoMock.AddUsersToChat mock is already set by Set")
	}

	if mmAddUsersToChat.defaultExpectation == nil {
		mmAddUsersToChat.defaultExpectation = &ChatRepoMockAddUsersToChatExpectation{}
	}

	if mmAddUsersToChat.defaultExpectation.params != nil {
		mmAddUsersToChat.mock.t.Fatalf("ChatRepoMock.AddUsersToChat mock is already set by Expect")
	}

	if mmAddUsersToChat.defaultExpectation.paramPtrs == nil {
		mmAddUsersToChat.defaultExpectation.paramPtrs = &ChatRepoMockAddUsersToChatParamPtrs{}
	}
	mmAddUsersToChat.defaultExpectation.paramPtrs.chatID = &chatID

	return mmAddUsersToChat
}

// ExpectUserIDsParam3 sets up expected param userIDs for ChatRepo.AddUsersToChat
func (mmAddUsersToChat *mChatRepoMockAddUsersToChat) ExpectUserIDsParam3(userIDs []int64) *mChatRepoMockAddUsersToChat {
	if mmAddUsersToChat.mock.funcAddUsersToChat != nil {
		mmAddUsersToChat.mock.t.Fatalf("ChatRepoMock.AddUsersToChat mock is already set by Set")
	}

	if mmAddUsersToChat.defaultExpectation == nil {
		mmAddUsersToChat.defaultExpectation = &ChatRepoMockAddUsersToChatExpectation{}
	}

	if mmAddUsersToChat.defaultExpectation.params != nil {
		mmAddUsersToChat.mock.t.Fatalf("ChatRepoMock.AddUsersToChat mock is already set by Expect")
	}

	if mmAddUsersToChat.defaultExpectation.paramPtrs == nil {
		mmAddUsersToChat.defaultExpectation.paramPtrs = &ChatRepoMockAddUsersToChatParamPtrs{}
	}
	mmAddUsersToChat.defaultExpectation.paramPtrs.userIDs = &userIDs

	return mmAddUsersToChat
}

// Inspect accepts an inspector function that has same arguments as the ChatRepo.AddUsersToChat
func (mmAddUsersToChat *mChatRepoMockAddUsersToChat) Inspect(f func(ctx context.Context, chatID int64, userIDs []int64)) *mChatRepoMockAddUsersToChat {
	if mmAddUsersToChat.mock.inspectFuncAddUsersToChat != nil {
		mmAddUsersToChat.mock.t.Fatalf("Inspect function is already set for ChatRepoMock.AddUsersToChat")
	}

	mmAddUsersToChat.mock.inspectFuncAddUsersToChat = f

	return mmAddUsersToChat
}

// Return sets up results that will be returned by ChatRepo.AddUsersToChat
func (mmAddUsersToChat *mChatRepoMockAddUsersToChat) Return(err error) *ChatRepoMock {
	if mmAddUsersToChat.mock.funcAddUsersToChat != nil {
		mmAddUsersToChat.mock.t.Fatalf("ChatRepoMock.AddUsersToChat mock is already set by Set")
	}

	if mmAddUsersToChat.defaultExpectation == nil {
		mmAddUsersToChat.defaultExpectation = &ChatRepoMockAddUsersToChatExpectation{mock: mmAddUsersToChat.mock}
	}
	mmAddUsersToChat.defaultExpectation.results = &ChatRepoMockAddUsersToChatResults{err}
	return mmAddUsersToChat.mock
}

// Set uses given function f to mock the ChatRepo.AddUsersToChat method
func (mmAddUsersToChat *mChatRepoMockAddUsersToChat) Set(f func(ctx context.Context, chatID int64, userIDs []int64) (err error)) *ChatRepoMock {
	if mmAddUsersToChat.defaultExpectation != nil {
		mmAddUsersToChat.mock.t.Fatalf("Default expectation is already set for the ChatRepo.AddUsersToChat method")
	}

	if len(mmAddUsersToChat.expectations) > 0 {
		mmAddUsersToChat.mock.t.Fatalf("Some expectations are already set for the ChatRepo.AddUsersToChat method")
	}

	mmAddUsersToChat.mock.funcAddUsersToChat = f
	return mmAddUsersToChat.mock
}

// When sets expectation for the ChatRepo.AddUsersToChat which will trigger the result defined by the following
// Then helper
func (mmAddUsersToChat *mChatRepoMockAddUsersToChat) When(ctx context.Context, chatID int64, userIDs []int64) *ChatRepoMockAddUsersToChatExpectation {
	if mmAddUsersToChat.mock.funcAddUsersToChat != nil {
		mmAddUsersToChat.mock.t.Fatalf("ChatRepoMock.AddUsersToChat mock is already set by Set")
	}

	expectation := &ChatRepoMockAddUsersToChatExpectation{
		mock:   mmAddUsersToChat.mock,
		params: &ChatRepoMockAddUsersToChatParams{ctx, chatID, userIDs},
	}
	mmAddUsersToChat.expectations = append(mmAddUsersToChat.expectations, expectation)
	return expectation
}

// Then sets up ChatRepo.AddUsersToChat return parameters for the expectation previously defined by the When method
func (e *ChatRepoMockAddUsersToChatExpectation) Then(err error) *ChatRepoMock {
	e.results = &ChatRepoMockAddUsersToChatResults{err}
	return e.mock
}

// Times sets number of times ChatRepo.AddUsersToChat should be invoked
func (mmAddUsersToChat *mChatRepoMockAddUsersToChat) Times(n uint64) *mChatRepoMockAddUsersToChat {
	if n == 0 {
		mmAddUsersToChat.mock.t.Fatalf("Times of ChatRepoMock.AddUsersToChat mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddUsersToChat.expectedInvocations, n)
	return mmAddUsersToChat
}

func (mmAddUsersToChat *mChatRepoMockAddUsersToChat) invocationsDone() bool {
	if len(mmAddUsersToChat.expectations) == 0 && mmAddUsersToChat.defaultExpectation == nil && mmAddUsersToChat.mock.funcAddUsersToChat == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddUsersToChat.mock.afterAddUsersToChatCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddUsersToChat.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddUsersToChat implements repository.ChatRepo
func (mmAddUsersToChat *ChatRepoMock) AddUsersToChat(ctx context.Context, chatID int64, userIDs []int64) (err error) {
	mm_atomic.AddUint64(&mmAddUsersToChat.beforeAddUsersToChatCounter, 1)
	defer mm_atomic.AddUint64(&mmAddUsersToChat.afterAddUsersToChatCounter, 1)

	if mmAddUsersToChat.inspectFuncAddUsersToChat != nil {
		mmAddUsersToChat.inspectFuncAddUsersToChat(ctx, chatID, userIDs)
	}

	mm_params := ChatRepoMockAddUsersToChatParams{ctx, chatID, userIDs}

	// Record call args
	mmAddUsersToChat.AddUsersToChatMock.mutex.Lock()
	mmAddUsersToChat.AddUsersToChatMock.callArgs = append(mmAddUsersToChat.AddUsersToChatMock.callArgs, &mm_params)
	mmAddUsersToChat.AddUsersToChatMock.mutex.Unlock()

	for _, e := range mmAddUsersToChat.AddUsersToChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddUsersToChat.AddUsersToChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddUsersToChat.AddUsersToChatMock.defaultExpectation.Counter, 1)
		mm_want := mmAddUsersToChat.AddUsersToChatMock.defaultExpectation.params
		mm_want_ptrs := mmAddUsersToChat.AddUsersToChatMock.defaultExpectation.paramPtrs

		mm_got := ChatRepoMockAddUsersToChatParams{ctx, chatID, userIDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddUsersToChat.t.Errorf("ChatRepoMock.AddUsersToChat got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.chatID != nil && !minimock.Equal(*mm_want_ptrs.chatID, mm_got.chatID) {
				mmAddUsersToChat.t.Errorf("ChatRepoMock.AddUsersToChat got unexpected parameter chatID, want: %#v, got: %#v%s\n", *mm_want_ptrs.chatID, mm_got.chatID, minimock.Diff(*mm_want_ptrs.chatID, mm_got.chatID))
			}

			if mm_want_ptrs.userIDs != nil && !minimock.Equal(*mm_want_ptrs.userIDs, mm_got.userIDs) {
				mmAddUsersToChat.t.Errorf("ChatRepoMock.AddUsersToChat got unexpected parameter userIDs, want: %#v, got: %#v%s\n", *mm_want_ptrs.userIDs, mm_got.userIDs, minimock.Diff(*mm_want_ptrs.userIDs, mm_got.userIDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddUsersToChat.t.Errorf("ChatRepoMock.AddUsersToChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddUsersToChat.AddUsersToChatMock.defaultExpectation.results
		if mm_results == nil {
			mmAddUsersToChat.t.Fatal("No results are set for the ChatRepoMock.AddUsersToChat")
		}
		return (*mm_results).err
	}
	if mmAddUsersToChat.funcAddUsersToChat != nil {
		return mmAddUsersToChat.funcAddUsersToChat(ctx, chatID, userIDs)
	}
	mmAddUsersToChat.t.Fatalf("Unexpected call to ChatRepoMock.AddUsersToChat. %v %v %v", ctx, chatID, userIDs)
	return
}

// AddUsersToChatAfterCounter returns a count of finished ChatRepoMock.AddUsersToChat invocations
func (mmAddUsersToChat *ChatRepoMock) AddUsersToChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddUsersToChat.afterAddUsersToChatCounter)
}

// AddUsersToChatBeforeCounter returns a count of ChatRepoMock.AddUsersToChat invocations
func (mmAddUsersToChat *ChatRepoMock) AddUsersToChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddUsersToChat.beforeAddUsersToChatCounter)
}

// Calls returns a list of arguments used in each call to ChatRepoMock.AddUsersToChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddUsersToChat *mChatRepoMockAddUsersToChat) Calls() []*ChatRepoMockAddUsersToChatParams {
	mmAddUsersToChat.mutex.RLock()

	argCopy := make([]*ChatRepoMockAddUsersToChatParams, len(mmAddUsersToChat.callArgs))
	copy(argCopy, mmAddUsersToChat.callArgs)

	mmAddUsersToChat.mutex.RUnlock()

	return argCopy
}

// MinimockAddUsersToChatDone returns true if the count of the AddUsersToChat invocations corresponds
// the number of defined expectations
func (m *ChatRepoMock) MinimockAddUsersToChatDone() bool {
	if m.AddUsersToChatMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddUsersToChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddUsersToChatMock.invocationsDone()
}

// MinimockAddUsersToChatInspect logs each unmet expectation
func (m *ChatRepoMock) MinimockAddUsersToChatInspect() {
	for _, e := range m.AddUsersToChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatRepoMock.AddUsersToChat with params: %#v", *e.params)
		}
	}

	afterAddUsersToChatCounter := mm_atomic.LoadUint64(&m.afterAddUsersToChatCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddUsersToChatMock.defaultExpectation != nil && afterAddUsersToChatCounter < 1 {
		if m.AddUsersToChatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatRepoMock.AddUsersToChat")
		} else {
			m.t.Errorf("Expected call to ChatRepoMock.AddUsersToChat with params: %#v", *m.AddUsersToChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddUsersToChat != nil && afterAddUsersToChatCounter < 1 {
		m.t.Error("Expected call to ChatRepoMock.AddUsersToChat")
	}

	if !m.AddUsersToChatMock.invocationsDone() && afterAddUsersToChatCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatRepoMock.AddUsersToChat but found %d calls",
			mm_atomic.LoadUint64(&m.AddUsersToChatMock.expectedInvocations), afterAddUsersToChatCounter)
	}
}

type mChatRepoMockCreateChat struct {
	optional           bool
	mock               *ChatRepoMock
	defaultExpectation *ChatRepoMockCreateChatExpectation
	expectations       []*ChatRepoMockCreateChatExpectation

	callArgs []*ChatRepoMockCreateChatParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ChatRepoMockCreateChatExpectation specifies expectation struct of the ChatRepo.CreateChat
type ChatRepoMockCreateChatExpectation struct {
	mock      *ChatRepoMock
	params    *ChatRepoMockCreateChatParams
	paramPtrs *ChatRepoMockCreateChatParamPtrs
	results   *ChatRepoMockCreateChatResults
	Counter   uint64
}

// ChatRepoMockCreateChatParams contains parameters of the ChatRepo.CreateChat
type ChatRepoMockCreateChatParams struct {
	ctx context.Context
	in  *model.CreateChatRequest
}

// ChatRepoMockCreateChatParamPtrs contains pointers to parameters of the ChatRepo.CreateChat
type ChatRepoMockCreateChatParamPtrs struct {
	ctx *context.Context
	in  **model.CreateChatRequest
}

// ChatRepoMockCreateChatResults contains results of the ChatRepo.CreateChat
type ChatRepoMockCreateChatResults struct {
	id  int64
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateChat *mChatRepoMockCreateChat) Optional() *mChatRepoMockCreateChat {
	mmCreateChat.optional = true
	return mmCreateChat
}

// Expect sets up expected params for ChatRepo.CreateChat
func (mmCreateChat *mChatRepoMockCreateChat) Expect(ctx context.Context, in *model.CreateChatRequest) *mChatRepoMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepoMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatRepoMockCreateChatExpectation{}
	}

	if mmCreateChat.defaultExpectation.paramPtrs != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepoMock.CreateChat mock is already set by ExpectParams functions")
	}

	mmCreateChat.defaultExpectation.params = &ChatRepoMockCreateChatParams{ctx, in}
	for _, e := range mmCreateChat.expectations {
		if minimock.Equal(e.params, mmCreateChat.defaultExpectation.params) {
			mmCreateChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateChat.defaultExpectation.params)
		}
	}

	return mmCreateChat
}

// ExpectCtxParam1 sets up expected param ctx for ChatRepo.CreateChat
func (mmCreateChat *mChatRepoMockCreateChat) ExpectCtxParam1(ctx context.Context) *mChatRepoMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepoMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatRepoMockCreateChatExpectation{}
	}

	if mmCreateChat.defaultExpectation.params != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepoMock.CreateChat mock is already set by Expect")
	}

	if mmCreateChat.defaultExpectation.paramPtrs == nil {
		mmCreateChat.defaultExpectation.paramPtrs = &ChatRepoMockCreateChatParamPtrs{}
	}
	mmCreateChat.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateChat
}

// ExpectInParam2 sets up expected param in for ChatRepo.CreateChat
func (mmCreateChat *mChatRepoMockCreateChat) ExpectInParam2(in *model.CreateChatRequest) *mChatRepoMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepoMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatRepoMockCreateChatExpectation{}
	}

	if mmCreateChat.defaultExpectation.params != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepoMock.CreateChat mock is already set by Expect")
	}

	if mmCreateChat.defaultExpectation.paramPtrs == nil {
		mmCreateChat.defaultExpectation.paramPtrs = &ChatRepoMockCreateChatParamPtrs{}
	}
	mmCreateChat.defaultExpectation.paramPtrs.in = &in

	return mmCreateChat
}

// Inspect accepts an inspector function that has same arguments as the ChatRepo.CreateChat
func (mmCreateChat *mChatRepoMockCreateChat) Inspect(f func(ctx context.Context, in *model.CreateChatRequest)) *mChatRepoMockCreateChat {
	if mmCreateChat.mock.inspectFuncCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("Inspect function is already set for ChatRepoMock.CreateChat")
	}

	mmCreateChat.mock.inspectFuncCreateChat = f

	return mmCreateChat
}

// Return sets up results that will be returned by ChatRepo.CreateChat
func (mmCreateChat *mChatRepoMockCreateChat) Return(id int64, err error) *ChatRepoMock {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepoMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatRepoMockCreateChatExpectation{mock: mmCreateChat.mock}
	}
	mmCreateChat.defaultExpectation.results = &ChatRepoMockCreateChatResults{id, err}
	return mmCreateChat.mock
}

// Set uses given function f to mock the ChatRepo.CreateChat method
func (mmCreateChat *mChatRepoMockCreateChat) Set(f func(ctx context.Context, in *model.CreateChatRequest) (id int64, err error)) *ChatRepoMock {
	if mmCreateChat.defaultExpectation != nil {
		mmCreateChat.mock.t.Fatalf("Default expectation is already set for the ChatRepo.CreateChat method")
	}

	if len(mmCreateChat.expectations) > 0 {
		mmCreateChat.mock.t.Fatalf("Some expectations are already set for the ChatRepo.CreateChat method")
	}

	mmCreateChat.mock.funcCreateChat = f
	return mmCreateChat.mock
}

// When sets expectation for the ChatRepo.CreateChat which will trigger the result defined by the following
// Then helper
func (mmCreateChat *mChatRepoMockCreateChat) When(ctx context.Context, in *model.CreateChatRequest) *ChatRepoMockCreateChatExpectation {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepoMock.CreateChat mock is already set by Set")
	}

	expectation := &ChatRepoMockCreateChatExpectation{
		mock:   mmCreateChat.mock,
		params: &ChatRepoMockCreateChatParams{ctx, in},
	}
	mmCreateChat.expectations = append(mmCreateChat.expectations, expectation)
	return expectation
}

// Then sets up ChatRepo.CreateChat return parameters for the expectation previously defined by the When method
func (e *ChatRepoMockCreateChatExpectation) Then(id int64, err error) *ChatRepoMock {
	e.results = &ChatRepoMockCreateChatResults{id, err}
	return e.mock
}

// Times sets number of times ChatRepo.CreateChat should be invoked
func (mmCreateChat *mChatRepoMockCreateChat) Times(n uint64) *mChatRepoMockCreateChat {
	if n == 0 {
		mmCreateChat.mock.t.Fatalf("Times of ChatRepoMock.CreateChat mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateChat.expectedInvocations, n)
	return mmCreateChat
}

func (mmCreateChat *mChatRepoMockCreateChat) invocationsDone() bool {
	if len(mmCreateChat.expectations) == 0 && mmCreateChat.defaultExpectation == nil && mmCreateChat.mock.funcCreateChat == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateChat.mock.afterCreateChatCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateChat.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateChat implements repository.ChatRepo
func (mmCreateChat *ChatRepoMock) CreateChat(ctx context.Context, in *model.CreateChatRequest) (id int64, err error) {
	mm_atomic.AddUint64(&mmCreateChat.beforeCreateChatCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateChat.afterCreateChatCounter, 1)

	if mmCreateChat.inspectFuncCreateChat != nil {
		mmCreateChat.inspectFuncCreateChat(ctx, in)
	}

	mm_params := ChatRepoMockCreateChatParams{ctx, in}

	// Record call args
	mmCreateChat.CreateChatMock.mutex.Lock()
	mmCreateChat.CreateChatMock.callArgs = append(mmCreateChat.CreateChatMock.callArgs, &mm_params)
	mmCreateChat.CreateChatMock.mutex.Unlock()

	for _, e := range mmCreateChat.CreateChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.id, e.results.err
		}
	}

	if mmCreateChat.CreateChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateChat.CreateChatMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateChat.CreateChatMock.defaultExpectation.params
		mm_want_ptrs := mmCreateChat.CreateChatMock.defaultExpectation.paramPtrs

		mm_got := ChatRepoMockCreateChatParams{ctx, in}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateChat.t.Errorf("ChatRepoMock.CreateChat got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmCreateChat.t.Errorf("ChatRepoMock.CreateChat got unexpected parameter in, want: %#v, got: %#v%s\n", *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateChat.t.Errorf("ChatRepoMock.CreateChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateChat.CreateChatMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateChat.t.Fatal("No results are set for the ChatRepoMock.CreateChat")
		}
		return (*mm_results).id, (*mm_results).err
	}
	if mmCreateChat.funcCreateChat != nil {
		return mmCreateChat.funcCreateChat(ctx, in)
	}
	mmCreateChat.t.Fatalf("Unexpected call to ChatRepoMock.CreateChat. %v %v", ctx, in)
	return
}

// CreateChatAfterCounter returns a count of finished ChatRepoMock.CreateChat invocations
func (mmCreateChat *ChatRepoMock) CreateChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChat.afterCreateChatCounter)
}

// CreateChatBeforeCounter returns a count of ChatRepoMock.CreateChat invocations
func (mmCreateChat *ChatRepoMock) CreateChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChat.beforeCreateChatCounter)
}

// Calls returns a list of arguments used in each call to ChatRepoMock.CreateChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateChat *mChatRepoMockCreateChat) Calls() []*ChatRepoMockCreateChatParams {
	mmCreateChat.mutex.RLock()

	argCopy := make([]*ChatRepoMockCreateChatParams, len(mmCreateChat.callArgs))
	copy(argCopy, mmCreateChat.callArgs)

	mmCreateChat.mutex.RUnlock()

	return argCopy
}

// MinimockCreateChatDone returns true if the count of the CreateChat invocations corresponds
// the number of defined expectations
func (m *ChatRepoMock) MinimockCreateChatDone() bool {
	if m.CreateChatMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateChatMock.invocationsDone()
}

// MinimockCreateChatInspect logs each unmet expectation
func (m *ChatRepoMock) MinimockCreateChatInspect() {
	for _, e := range m.CreateChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatRepoMock.CreateChat with params: %#v", *e.params)
		}
	}

	afterCreateChatCounter := mm_atomic.LoadUint64(&m.afterCreateChatCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateChatMock.defaultExpectation != nil && afterCreateChatCounter < 1 {
		if m.CreateChatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatRepoMock.CreateChat")
		} else {
			m.t.Errorf("Expected call to ChatRepoMock.CreateChat with params: %#v", *m.CreateChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateChat != nil && afterCreateChatCounter < 1 {
		m.t.Error("Expected call to ChatRepoMock.CreateChat")
	}

	if !m.CreateChatMock.invocationsDone() && afterCreateChatCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatRepoMock.CreateChat but found %d calls",
			mm_atomic.LoadUint64(&m.CreateChatMock.expectedInvocations), afterCreateChatCounter)
	}
}

type mChatRepoMockDeleteChat struct {
	optional           bool
	mock               *ChatRepoMock
	defaultExpectation *ChatRepoMockDeleteChatExpectation
	expectations       []*ChatRepoMockDeleteChatExpectation

	callArgs []*ChatRepoMockDeleteChatParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ChatRepoMockDeleteChatExpectation specifies expectation struct of the ChatRepo.DeleteChat
type ChatRepoMockDeleteChatExpectation struct {
	mock      *ChatRepoMock
	params    *ChatRepoMockDeleteChatParams
	paramPtrs *ChatRepoMockDeleteChatParamPtrs
	results   *ChatRepoMockDeleteChatResults
	Counter   uint64
}

// ChatRepoMockDeleteChatParams contains parameters of the ChatRepo.DeleteChat
type ChatRepoMockDeleteChatParams struct {
	ctx context.Context
	id  int64
}

// ChatRepoMockDeleteChatParamPtrs contains pointers to parameters of the ChatRepo.DeleteChat
type ChatRepoMockDeleteChatParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// ChatRepoMockDeleteChatResults contains results of the ChatRepo.DeleteChat
type ChatRepoMockDeleteChatResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteChat *mChatRepoMockDeleteChat) Optional() *mChatRepoMockDeleteChat {
	mmDeleteChat.optional = true
	return mmDeleteChat
}

// Expect sets up expected params for ChatRepo.DeleteChat
func (mmDeleteChat *mChatRepoMockDeleteChat) Expect(ctx context.Context, id int64) *mChatRepoMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepoMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatRepoMockDeleteChatExpectation{}
	}

	if mmDeleteChat.defaultExpectation.paramPtrs != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepoMock.DeleteChat mock is already set by ExpectParams functions")
	}

	mmDeleteChat.defaultExpectation.params = &ChatRepoMockDeleteChatParams{ctx, id}
	for _, e := range mmDeleteChat.expectations {
		if minimock.Equal(e.params, mmDeleteChat.defaultExpectation.params) {
			mmDeleteChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteChat.defaultExpectation.params)
		}
	}

	return mmDeleteChat
}

// ExpectCtxParam1 sets up expected param ctx for ChatRepo.DeleteChat
func (mmDeleteChat *mChatRepoMockDeleteChat) ExpectCtxParam1(ctx context.Context) *mChatRepoMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepoMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatRepoMockDeleteChatExpectation{}
	}

	if mmDeleteChat.defaultExpectation.params != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepoMock.DeleteChat mock is already set by Expect")
	}

	if mmDeleteChat.defaultExpectation.paramPtrs == nil {
		mmDeleteChat.defaultExpectation.paramPtrs = &ChatRepoMockDeleteChatParamPtrs{}
	}
	mmDeleteChat.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteChat
}

// ExpectIdParam2 sets up expected param id for ChatRepo.DeleteChat
func (mmDeleteChat *mChatRepoMockDeleteChat) ExpectIdParam2(id int64) *mChatRepoMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepoMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatRepoMockDeleteChatExpectation{}
	}

	if mmDeleteChat.defaultExpectation.params != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepoMock.DeleteChat mock is already set by Expect")
	}

	if mmDeleteChat.defaultExpectation.paramPtrs == nil {
		mmDeleteChat.defaultExpectation.paramPtrs = &ChatRepoMockDeleteChatParamPtrs{}
	}
	mmDeleteChat.defaultExpectation.paramPtrs.id = &id

	return mmDeleteChat
}

// Inspect accepts an inspector function that has same arguments as the ChatRepo.DeleteChat
func (mmDeleteChat *mChatRepoMockDeleteChat) Inspect(f func(ctx context.Context, id int64)) *mChatRepoMockDeleteChat {
	if mmDeleteChat.mock.inspectFuncDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("Inspect function is already set for ChatRepoMock.DeleteChat")
	}

	mmDeleteChat.mock.inspectFuncDeleteChat = f

	return mmDeleteChat
}

// Return sets up results that will be returned by ChatRepo.DeleteChat
func (mmDeleteChat *mChatRepoMockDeleteChat) Return(err error) *ChatRepoMock {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepoMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatRepoMockDeleteChatExpectation{mock: mmDeleteChat.mock}
	}
	mmDeleteChat.defaultExpectation.results = &ChatRepoMockDeleteChatResults{err}
	return mmDeleteChat.mock
}

// Set uses given function f to mock the ChatRepo.DeleteChat method
func (mmDeleteChat *mChatRepoMockDeleteChat) Set(f func(ctx context.Context, id int64) (err error)) *ChatRepoMock {
	if mmDeleteChat.defaultExpectation != nil {
		mmDeleteChat.mock.t.Fatalf("Default expectation is already set for the ChatRepo.DeleteChat method")
	}

	if len(mmDeleteChat.expectations) > 0 {
		mmDeleteChat.mock.t.Fatalf("Some expectations are already set for the ChatRepo.DeleteChat method")
	}

	mmDeleteChat.mock.funcDeleteChat = f
	return mmDeleteChat.mock
}

// When sets expectation for the ChatRepo.DeleteChat which will trigger the result defined by the following
// Then helper
func (mmDeleteChat *mChatRepoMockDeleteChat) When(ctx context.Context, id int64) *ChatRepoMockDeleteChatExpectation {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepoMock.DeleteChat mock is already set by Set")
	}

	expectation := &ChatRepoMockDeleteChatExpectation{
		mock:   mmDeleteChat.mock,
		params: &ChatRepoMockDeleteChatParams{ctx, id},
	}
	mmDeleteChat.expectations = append(mmDeleteChat.expectations, expectation)
	return expectation
}

// Then sets up ChatRepo.DeleteChat return parameters for the expectation previously defined by the When method
func (e *ChatRepoMockDeleteChatExpectation) Then(err error) *ChatRepoMock {
	e.results = &ChatRepoMockDeleteChatResults{err}
	return e.mock
}

// Times sets number of times ChatRepo.DeleteChat should be invoked
func (mmDeleteChat *mChatRepoMockDeleteChat) Times(n uint64) *mChatRepoMockDeleteChat {
	if n == 0 {
		mmDeleteChat.mock.t.Fatalf("Times of ChatRepoMock.DeleteChat mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteChat.expectedInvocations, n)
	return mmDeleteChat
}

func (mmDeleteChat *mChatRepoMockDeleteChat) invocationsDone() bool {
	if len(mmDeleteChat.expectations) == 0 && mmDeleteChat.defaultExpectation == nil && mmDeleteChat.mock.funcDeleteChat == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteChat.mock.afterDeleteChatCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteChat.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteChat implements repository.ChatRepo
func (mmDeleteChat *ChatRepoMock) DeleteChat(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteChat.beforeDeleteChatCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteChat.afterDeleteChatCounter, 1)

	if mmDeleteChat.inspectFuncDeleteChat != nil {
		mmDeleteChat.inspectFuncDeleteChat(ctx, id)
	}

	mm_params := ChatRepoMockDeleteChatParams{ctx, id}

	// Record call args
	mmDeleteChat.DeleteChatMock.mutex.Lock()
	mmDeleteChat.DeleteChatMock.callArgs = append(mmDeleteChat.DeleteChatMock.callArgs, &mm_params)
	mmDeleteChat.DeleteChatMock.mutex.Unlock()

	for _, e := range mmDeleteChat.DeleteChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteChat.DeleteChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteChat.DeleteChatMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteChat.DeleteChatMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteChat.DeleteChatMock.defaultExpectation.paramPtrs

		mm_got := ChatRepoMockDeleteChatParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteChat.t.Errorf("ChatRepoMock.DeleteChat got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteChat.t.Errorf("ChatRepoMock.DeleteChat got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteChat.t.Errorf("ChatRepoMock.DeleteChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteChat.DeleteChatMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteChat.t.Fatal("No results are set for the ChatRepoMock.DeleteChat")
		}
		return (*mm_results).err
	}
	if mmDeleteChat.funcDeleteChat != nil {
		return mmDeleteChat.funcDeleteChat(ctx, id)
	}
	mmDeleteChat.t.Fatalf("Unexpected call to ChatRepoMock.DeleteChat. %v %v", ctx, id)
	return
}

// DeleteChatAfterCounter returns a count of finished ChatRepoMock.DeleteChat invocations
func (mmDeleteChat *ChatRepoMock) DeleteChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChat.afterDeleteChatCounter)
}

// DeleteChatBeforeCounter returns a count of ChatRepoMock.DeleteChat invocations
func (mmDeleteChat *ChatRepoMock) DeleteChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChat.beforeDeleteChatCounter)
}

// Calls returns a list of arguments used in each call to ChatRepoMock.DeleteChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteChat *mChatRepoMockDeleteChat) Calls() []*ChatRepoMockDeleteChatParams {
	mmDeleteChat.mutex.RLock()

	argCopy := make([]*ChatRepoMockDeleteChatParams, len(mmDeleteChat.callArgs))
	copy(argCopy, mmDeleteChat.callArgs)

	mmDeleteChat.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteChatDone returns true if the count of the DeleteChat invocations corresponds
// the number of defined expectations
func (m *ChatRepoMock) MinimockDeleteChatDone() bool {
	if m.DeleteChatMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteChatMock.invocationsDone()
}

// MinimockDeleteChatInspect logs each unmet expectation
func (m *ChatRepoMock) MinimockDeleteChatInspect() {
	for _, e := range m.DeleteChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatRepoMock.DeleteChat with params: %#v", *e.params)
		}
	}

	afterDeleteChatCounter := mm_atomic.LoadUint64(&m.afterDeleteChatCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteChatMock.defaultExpectation != nil && afterDeleteChatCounter < 1 {
		if m.DeleteChatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatRepoMock.DeleteChat")
		} else {
			m.t.Errorf("Expected call to ChatRepoMock.DeleteChat with params: %#v", *m.DeleteChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteChat != nil && afterDeleteChatCounter < 1 {
		m.t.Error("Expected call to ChatRepoMock.DeleteChat")
	}

	if !m.DeleteChatMock.invocationsDone() && afterDeleteChatCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatRepoMock.DeleteChat but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteChatMock.expectedInvocations), afterDeleteChatCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ChatRepoMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddUsersToChatInspect()

			m.MinimockCreateChatInspect()

			m.MinimockDeleteChatInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ChatRepoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ChatRepoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddUsersToChatDone() &&
		m.MinimockCreateChatDone() &&
		m.MinimockDeleteChatDone()
}
